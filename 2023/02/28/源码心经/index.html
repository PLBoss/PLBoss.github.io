

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="二叉树链式存储：含有左右指针，将指散落在各个地址的指针通过节点串联起来 顺序存储：有序的存放在数组中 递归先取出整体问题的一小份，然后把剩余的问题交给其他人处理，注意边界 查找704. 二分查找  12345678910111213141516171819202122232425262728293031public int search(int[] nums, int target) &amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="源码心经">
<meta property="og:url" content="http://example.com/2023/02/28/%E6%BA%90%E7%A0%81%E5%BF%83%E7%BB%8F/index.html">
<meta property="og:site_name" content="RawCode">
<meta property="og:description" content="二叉树链式存储：含有左右指针，将指散落在各个地址的指针通过节点串联起来 顺序存储：有序的存放在数组中 递归先取出整体问题的一小份，然后把剩余的问题交给其他人处理，注意边界 查找704. 二分查找  12345678910111213141516171819202122232425262728293031public int search(int[] nums, int target) &amp;#123;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://plboss-imges.oss-cn-chengdu.aliyuncs.com/master/image-20230108231052359.png">
<meta property="og:image" content="https://plboss-imges.oss-cn-chengdu.aliyuncs.com/master/image-20230222225838810.png">
<meta property="article:published_time" content="2023-02-28T12:31:36.000Z">
<meta property="article:modified_time" content="2023-02-28T12:33:36.663Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://plboss-imges.oss-cn-chengdu.aliyuncs.com/master/image-20230108231052359.png">
  
  
  
  <title>源码心经 - RawCode</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>RawCode</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="源码心经"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-28 20:31" pubdate>
          February 28, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          78k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          653 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">源码心经</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>链式存储：含有左右指针，将指散落在各个地址的指针通过节点串联起来</p>
<p>顺序存储：有序的存放在数组中</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>先取出整体问题的一小份，然后把剩余的问题交给其他人处理，注意边界</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/submissions/">704. 二分查找 </a></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs excel">public <span class="hljs-built_in">int</span> <span class="hljs-built_in">search</span>(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> target) &#123;<br>      /* <br>      一个排序数组，定义两个指针，一个指向数组的头部，一个指向数组的尾部，还有一个中间指针指向左右指针的中间<br>      只有左指针小于等于右指针，就不断循环，如果中间指针等于要找的目标值就返回，<br>      反之，目标值大于中间指针的值，将左指针更新为中间指针的下一个。<br>      当目标值小于中间指针的值，就将右指针更新为中间指针的前一个，如果一直每找到就返回-<span class="hljs-number">1</span>。<br>      <br>      */<br>      <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>=<span class="hljs-number">0</span>;<br>      <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>=nums.length-<span class="hljs-number">1</span>;<br>      <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span>=<span class="hljs-built_in">left</span>+(<span class="hljs-built_in">right</span>-<span class="hljs-built_in">left</span>)/<span class="hljs-number">2</span>;<br>      while(<span class="hljs-built_in">left</span>&lt;=<span class="hljs-built_in">right</span>)<br>      &#123;<br>          <span class="hljs-built_in">mid</span>=<span class="hljs-built_in">left</span>+(<span class="hljs-built_in">right</span>-<span class="hljs-built_in">left</span>)/<span class="hljs-number">2</span>;<br>          <span class="hljs-built_in">if</span>(nums[<span class="hljs-built_in">mid</span>]==target)&#123;<br>              return <span class="hljs-built_in">mid</span>;<br><br><br>          &#125;else <span class="hljs-built_in">if</span>(nums[<span class="hljs-built_in">mid</span>]&lt;target)&#123;<br>              <span class="hljs-built_in">left</span>=<span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span>;<br><br>          &#125;else <span class="hljs-built_in">if</span>(nums[<span class="hljs-built_in">mid</span>]&gt;target)&#123;<br>              <span class="hljs-built_in">right</span>=<span class="hljs-built_in">mid</span>-<span class="hljs-number">1</span>;<br><br>          &#125;<br><br>      &#125;<br><br>      return -<span class="hljs-number">1</span>;<br><br>  &#125;<br></code></pre></td></tr></table></figure>



<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>将数组分成左右两半，然后将左右两部分排序好后，在进行合并</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组 </a></p>
<p>未处理当一个数组中全是同一个元素的情况</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public <span class="hljs-built_in">int</span>[] sortArray(<span class="hljs-built_in">int</span>[] nums) &#123;<br><br>        /*<br>        快速排序：<br>        递归三要素<span class="hljs-symbol">:</span><br>        传入参数和返回值类型<span class="hljs-symbol">:</span>传入一个代排序的数组，左右指针，没有返回<br>        终止条件，左指针大于右指针<br>        单次循环逻辑：定义一个基准值（最左边的值），右指针先移动，右指针直到找到小于基准值的值，就停止移动，<br>        然后移动左指针，左指针移动到直到找到比基准大的值，然后就交换这两个值，一直移动到左右 指针相等，这时候<br>        就将基准值和相遇的值交换，然后递归排序分解点左右两边的值<br>        <br>        <br>         */ <br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>=nums.length-<span class="hljs-number">1</span>;<br>         quicksort(nums,<span class="hljs-built_in">left</span>,<span class="hljs-built_in">right</span>);<br><br>         return nums;<br><br><br><br>    &#125;<br><br>    public void quicksort(<span class="hljs-built_in">int</span>[] nums,<span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>,<span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>)&#123;<br>        <span class="hljs-built_in">if</span>(<span class="hljs-built_in">left</span>&gt;<span class="hljs-built_in">right</span>)<br>        &#123;<br>            return;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> i=<span class="hljs-built_in">left</span>;<br>        <span class="hljs-built_in">int</span> j=<span class="hljs-built_in">right</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">base</span>=nums[<span class="hljs-built_in">left</span>];<br><br>        while(i!=j)&#123;<br><br>            while(nums[j]&gt;=<span class="hljs-built_in">base</span>&amp;i&lt;j)&#123;<br>                j--;<br><br><br>            &#125;<br><br>            while(nums[i]&lt;=<span class="hljs-built_in">base</span>&amp;i&lt;j)&#123;<br>                i++;<br><br><br>            &#125;<br>            <span class="hljs-built_in">if</span>(i&gt;j)&#123;<br>                break;<br>            &#125;<br>            <span class="hljs-built_in">if</span>(i&lt;j)&#123;<br><br>                <span class="hljs-built_in">int</span> temp=nums[j];<br>                nums[j]=nums[i];<br>                nums[i]=temp;<br>            &#125;<br><br>            <br><br><br><br>        &#125;<br><br>        nums[<span class="hljs-built_in">left</span>]=nums[i];<br>        nums[i]=<span class="hljs-built_in">base</span>;<br><br>        quicksort(nums,<span class="hljs-built_in">left</span>,i-<span class="hljs-number">1</span>);<br>        quicksort(nums,i+<span class="hljs-number">1</span>,<span class="hljs-built_in">right</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/submissions/">215. 数组中的第K个最大元素 </a></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs excel">public <span class="hljs-built_in">int</span> findKthLargest(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> k) &#123;<br><br>   /*<br>   先通过快速排序，从大到小进行排序，然后返回数组 中的第k个元素即可<br>   快速排序：<br>    单次循环逻辑<br>       找一个基准数，基准数取左边的第一个，然后定义两个指针，左指针初始指向基础数，<br>       右指针指向数组的末尾，然后右指针先移动，右指针负责找比基准数大的数，等找到比<br>       基准数大的数就停止移动，然后移动左指针，左指针负责寻找比基准数小的数，找到之后，<br>       就交换这两二个指针代表的值，只要左指针不大于右指针就可以一直重复上面的步奏，<br>       等到左右指针相遇的时候，就开始交换基准数的值与相遇位置指针的值，交换结束后，<br>       然后递归排序以及准数为界的左右部分。<br>   递归的停止条件<span class="hljs-symbol">:</span>左指针大于右指针<br>   传入参数和返回：数组，左右指针<br><br>   <br>    */ <br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>=nums.length-<span class="hljs-number">1</span>;<br><br>    quikesort(nums,<span class="hljs-built_in">left</span>,<span class="hljs-built_in">right</span>);<br><br>    return nums[k-<span class="hljs-number">1</span>];<br><br>   &#125;<br><br>   public void quikesort(<span class="hljs-built_in">int</span>[] nums,<span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>,<span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>)&#123;<br>       <span class="hljs-built_in">if</span>(<span class="hljs-built_in">left</span>&gt;<span class="hljs-built_in">right</span>)&#123;<br>           return;<br>       &#125;<br><br>       <span class="hljs-built_in">int</span> <span class="hljs-built_in">base</span>=nums[<span class="hljs-built_in">left</span>];<br>       <span class="hljs-built_in">int</span> i=<span class="hljs-built_in">left</span>;<br>       <span class="hljs-built_in">int</span> j=<span class="hljs-built_in">right</span>;<br><br>       while(i!=j)&#123;<br>           <br>           //右指针先移动<br>           while(nums[j]&lt;=<span class="hljs-built_in">base</span>&amp;i&lt;j)&#123;<br>               j--;<br>           &#125;<br>           //左指针移动<br>           while(nums[i]&gt;=<span class="hljs-built_in">base</span>&amp;i&lt;j)&#123;<br>               i++;<br>           &#125;<br><br>           <span class="hljs-built_in">int</span> temp=nums[j];<br>           nums[j]=nums[i];<br>           nums[i]=temp;<br><br>       &#125;<br>       nums[<span class="hljs-built_in">left</span>]=nums[i];<br>       nums[i]=<span class="hljs-built_in">base</span>;<br><br>       quikesort(nums,<span class="hljs-built_in">left</span>,i-<span class="hljs-number">1</span>);<br>       quikesort(nums,i+<span class="hljs-number">1</span>,<span class="hljs-built_in">right</span>);<br><br><br><br><br>   &#125;<br></code></pre></td></tr></table></figure>

<h4 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h4><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是存放在连续内存空间的相同数据类型的集合。</p>
<p>特点：</p>
<p>带有下标，下标都是从零开始的</p>
<p>内存地址的是连续的</p>
<p>优点：</p>
<p>方便查找</p>
<p>缺点：</p>
<p>删除与添加元素都有费劲，因为数组的地址值是连续的，所以增加与删除元素都需要移动其他元素</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Integer.MAX_VALUE<span class="hljs-comment">;最大值</span><br></code></pre></td></tr></table></figure>

<p>在一个有序的数组中进行查找，注意不要出现重复</p>
<p>思路：定义三个指针（left,mid,right),在一个循环（while）下不断收缩范围,循环的条件是（left&lt;=right),然后判断目标值与mid值得大小，目标值大与mid值，就left=mid+1,反之，就right=mid-1.直到找到目标值就返回目标值mid.没有找到就返回-1.</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/submissions/">35. 搜索插入位置 -  </a></p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coq">/*<br>思路：<br>首先判断该数与最大值最小值进行比较，小于就返回<span class="hljs-number">0</span>，大于就返回数组的长度加一，也就是<span class="hljs-built_in">right</span>+<span class="hljs-number">1.</span><br>对于在数组中的数，一种是存在的，一种是不存在的，都统一成返回做下标<br>对于存在的数的数使用二分查找法，最终就能返回该数存在的下标。<br>然后对于不存在,没有找到的自然就是不存在的，结合特特殊情况大于最大值的情况可得，<br>最终不存在的数<br>插入的位置乃是二分法最后的<span class="hljs-built_in">right</span>+<span class="hljs-number">1</span>，到这里问题也解决了<br>        <br>        <br>*/<br></code></pre></td></tr></table></figure>

<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs excel">public <span class="hljs-built_in">int</span> searchInsert(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> target) &#123;<br>       /*<br>       思路：<br>       本地的难点就是处理不在数组中的情况，不在数组中，插入的位置就是最后统一成<span class="hljs-built_in">right</span>+<span class="hljs-number">1</span><br>       因为当插入的数字大于整个数组时，插入的位置，就是最后一个位置加一<br>       <br>       <br>        */<br><br>       <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>=<span class="hljs-number">0</span>;<br>       <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>=nums.length-<span class="hljs-number">1</span>;<br><br>       <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span>=<span class="hljs-built_in">left</span>+(<span class="hljs-built_in">right</span>-<span class="hljs-built_in">left</span>)/<span class="hljs-number">2</span>;<br>       <span class="hljs-built_in">if</span>(target&lt;nums[<span class="hljs-number">0</span>])&#123;<br>           return <span class="hljs-number">0</span>;<br>       &#125;<br><br>       while(<span class="hljs-built_in">left</span>&lt;=<span class="hljs-built_in">right</span>)&#123;<br>            <span class="hljs-built_in">mid</span>=<span class="hljs-built_in">left</span>+(<span class="hljs-built_in">right</span>-<span class="hljs-built_in">left</span>)/<span class="hljs-number">2</span>;<br><br>           <span class="hljs-built_in">if</span>(nums[<span class="hljs-built_in">mid</span>]==target)&#123;<br><br>               return <span class="hljs-built_in">mid</span>;<br><br>           &#125;else <span class="hljs-built_in">if</span>(nums[<span class="hljs-built_in">mid</span>]&lt;target)&#123;<br>               <span class="hljs-built_in">left</span>=<span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span>;<br><br><br>           &#125;else <span class="hljs-built_in">if</span>(nums[<span class="hljs-built_in">mid</span>]&gt;target)&#123;<br>               <span class="hljs-built_in">right</span>=<span class="hljs-built_in">mid</span>-<span class="hljs-number">1</span>;<br><br><br><br>           &#125;<br>   &#125;<br><br><br>   return <span class="hljs-built_in">right</span>+<span class="hljs-number">1</span>;<br><br>   &#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://plboss-imges.oss-cn-chengdu.aliyuncs.com/master/image-20230108231052359.png" srcset="/img/loading.gif" lazyload alt="image-20230108231052359"></p>
<p>注意：插入位置的判断</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置 -  </a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">暴力解法：<br>遍历依次依次数组，然后记录刚好等于目标值的下标，然后再记录，刚好不等于的<br>下标值减一<br></code></pre></td></tr></table></figure>

<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">二分查找法解决<br>  /* <br>        首先看特殊情况：目标值不在数组范围内的和在范围内的但不存在的，返回[<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>]。<br>        然后就是在范围内且存在的，需要寻在开头与结束的位置。<br>        左边界与右边界的位置分别使用二分法，求得，与二分法不同的是，等于也会被包含进去，为了求得边界。<br>        左边界，从右往左求，右边界从左往右求。<br>        */<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br><br>      <br>        <span class="hljs-keyword">int</span> boder_left=searchLeft(nums,target);<br>        <span class="hljs-keyword">int</span> boder_right=searchRight(nums,target);<br><br>        <span class="hljs-keyword">int</span> l=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//数组长度为0的</span><br>       <span class="hljs-keyword">if</span>(l==-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>       &#125;<br>       <span class="hljs-comment">//不在范围内的</span><br>        <span class="hljs-keyword">if</span>(target&lt;nums[<span class="hljs-number">0</span>] || target&gt;nums[l])&#123;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>        &#125;<br>        <span class="hljs-comment">//在范围里且存在</span><br>        <span class="hljs-keyword">if</span>(boder_right-boder_left&gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;boder_left+<span class="hljs-number">1</span>,boder_right-<span class="hljs-number">1</span>&#125;;<br>        &#125;<br><br>        <span class="hljs-comment">//在范围里不存</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>        <br><br>    <br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchLeft</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> boder_left=-<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> mid=right+(left-right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            mid=right+(left-right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;=target)&#123;<br>                right=mid-<span class="hljs-number">1</span>;<br>                boder_left=right;<br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> boder_left;<br><br><br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchRight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)</span></span>&#123;<br>         <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> boder_right=-<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> mid=right+(left-right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            mid=right+(left-right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;=target)&#123;<br>              left=mid+<span class="hljs-number">1</span>;<br>              boder_right=left;<br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right=mid-<span class="hljs-number">1</span>;<br><br>            &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> boder_right;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>右边界找左指针，左边界找右指针</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/submissions/">69. x 的平方根 -  </a></p>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/submissions/">26. 删除有序数组中的重复项 -  </a></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">/* </span><br><span class="hljs-comment">        快慢指针法：定义两个指针，一个慢指针，一个快指针，慢指针用于更新数组，快指针用于找不重复的元素，</span><br><span class="hljs-comment">        然后直到快指针遍历到</span><br><span class="hljs-comment">        数组末尾，就返回慢指针的后一个即可，即去重后的数组长度.这里需要注意的是，每次都要先移动后赋值，</span><br><span class="hljs-comment">        为了避免多次覆盖同一个元素。</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">int</span> slow=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast=<span class="hljs-number">0</span>;fast&lt;nums.<span class="hljs-built_in">length</span>;fast++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast]!=nums[slow])&#123;<br>                slow++;<br>                nums[slow]=nums[fast];<br>                <br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> slow+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/solution/">283. 移动零 题解 -  </a></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/* </span><br><span class="hljs-comment">       双指针：</span><br><span class="hljs-comment">       快慢指针法：定义两个指针，一个慢指针，一个快指针，慢指针用于更新数组，快指针用于寻找不是0的元素，</span><br><span class="hljs-comment">       然后与慢指针进行</span><br><span class="hljs-comment">       交换，即可，直到快指针达到结尾</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">       */</span><br><br>       <span class="hljs-type">int</span> slow=<span class="hljs-number">0</span>;<br><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast=<span class="hljs-number">0</span>;fast&lt;nums.length;fast++)&#123;<br>           <span class="hljs-keyword">if</span>(nums[fast]!=<span class="hljs-number">0</span>)&#123;<br>               <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span>=nums[fast];<br>               nums[fast]=nums[slow];<br>               nums[slow]=<span class="hljs-keyword">temp</span>;<br>               slow++;<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure>

<p>*<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串 -  </a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">        思路：从后往遍历数组，定义一个指针用于记录退格键的数量，当指针为退格键时就加一，不是退格键</span><br><span class="hljs-comment">        时，当记录的退格键数目不为零时，就删去该字符，反之则不删除。</span><br><span class="hljs-comment">        整个逻辑为再一个大循环中，嵌套两个小循环，大循环用于旁段两个字符串的对应不删除位置的字符是否相同，</span><br><span class="hljs-comment">        小循环是用于进行删除字符。</span><br><span class="hljs-comment">         */</span><br><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/submissions/">977. 有序数组的平方 -  </a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">      思路：首先定义一个新数组,长度和原始数组长度一样，用于存放排序后的数组，定义一个指针指向新数组的最后面。</span><br><span class="hljs-comment">      其次再定义两个指针，一个指针指向原始数组最前面，一个指针指向最后面，因为这个数组最大值都是出现在两边（有负数的情况）</span><br><span class="hljs-comment">      ，然后比较两个指针代表的值，将大的值赋值给新数组，然后这个指针和新数组的指针进行移动</span><br><span class="hljs-comment">       */</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/submissions/">209. 长度最小的子数组 -  </a></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">思路：使用滑动窗口，定义一个开始指针，定义一个循环用与遍历数组，<br>  还有充当滑动窗口的末尾指针的作用，循环类还要嵌套一个当型循环，用于动态更新开始指针的位置，<br>  当开始指针与末尾指针的和大于等于最小值时，就进行循环，取出这时的区间长度和原始最小区间结果进行比较，<br>  如果这个新的区间长度小于原始区间长度，就更新长度，反之则不更新。然后将开始指针的值从本次结果中剔除，<br>  开始指针加一，为的是从下一个值开始重新判断数组和与<span class="hljs-literal">result</span>的结果大小。注意，找不到数组和大于target的数情况<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fruit-into-baskets/submissions/">904. 水果成篮 -  </a></p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">/*</span><br><span class="hljs-comment">      思路：滑动窗口，定义一个开始指针，还有一个大循环，大循环的次数就是结尾指针。还要嵌套一个当型循环，</span><br><span class="hljs-comment">      用于动态更新窗口的大小以及开始指针的位置。还有一个哈希表map用于记录窗口内值出现的次数。</span><br><span class="hljs-comment">      不断移动尾部指针并放入哈希表内，当哈希表的长度大于2时，就移动开始指针的位置，</span><br><span class="hljs-comment">      并将上一个的尾部指针代表的值从哈希表从减一，以便于使得哈希表长度小于2，</span><br><span class="hljs-comment">      当开始指针在哈希表中出现的次数为0时，就将这个键也从哈希表中删除</span><br><span class="hljs-comment">.当原始窗口的最大值小于现在的窗口值，就将窗口最大值更新为现在的窗口值大小        </span><br><span class="hljs-comment">      */</span><br>      <span class="hljs-built_in">getOrDefault</span>() 方法获取指定 <span class="hljs-built_in">key</span> 对应对 value，如果找不到 <span class="hljs-built_in">key</span> ，则返回设置的默认值。<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串 -  </a></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Integer.MAX_VALUE;<br>substring<span class="hljs-literal">()</span>:取字串<br>contains<span class="hljs-constructor">Key()</span>:<br>values:返回哈希表的所有值<br><span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>:转换成字符数组<br><span class="hljs-built_in">char</span><span class="hljs-constructor">At()</span>:转换成字符<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">思路：</span><br><span class="hljs-comment">滑动窗口，定义两个指针，都从起始位置开始。还要定义一个哈希表，用于记录覆盖字符串中的字符的在窗口内的出现情况，初始都为1,表示都为出现，当值都小于0时，就表示字符串中所有的值都已出现在窗口中。</span><br><span class="hljs-comment">当右指针指向的字符时是要覆盖的字符，就将将哈希表中该字符的次数减一。当窗口内没有包含覆盖的字符串，右指针就一直向前移动。当出现了所有覆盖字符都在窗口中出现时，即哈希表的值都为负数，</span><br><span class="hljs-comment">就记录下该窗口的起始位置和窗口大小，并且开始移动左指针，移动左指针后，如果窗口内还包含要覆盖的字符串，如果新窗口的大小小于上一次记录的窗口大小，则更新窗口值大小和起始位置，反之则不更新，</span><br><span class="hljs-comment">且开始移动右指针，当右指针走到字符串尾部后，循环结束，返回结果</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/submissions/">59. 螺旋矩阵 II -  </a></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">思路：<br>    需要确定的量：循环的圈数（<span class="hljs-built_in">n</span>/<span class="hljs-number">2</span>），每次开始循环的位置，循环的边界（循环完一次，边界数加一）.<br>    特殊情况的处理，当<span class="hljs-built_in">n</span>为奇数时，最后一次循环不完整，所以最后一个值需要单独处理。注意每次赋值的区间选择，要统一。<br>    每次循环结束后到要重新将开始位置定位到新的起点，而不是上一次循环结束的位置。<br></code></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h3><p>1.链表由两部分构成，一部分是数据域，一部分是指针域，指针域指向下一个节点的数据空，而最后一个指针指向为空</p>
<h3 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h3><p>单链表：只能从前往后查找</p>
<p>双链表：既可以向前查找也可以向后查找，双链表含有两个指针域，即头指针域和后指针域</p>
<p>循环链表：指的是首位连接在一起的链表</p>
<h3 id="链表的存储"><a href="#链表的存储" class="headerlink" title="链表的存储"></a>链表的存储</h3><p>数组是在内存中连续分布的</p>
<p>链表通过指针连系在一起的，他是随机分配在内存中</p>
<h3 id="链表的优点"><a href="#链表的优点" class="headerlink" title="链表的优点"></a>链表的优点</h3><p>链表可以动态的申请空间大小，数组是固定长度的</p>
<p>链表方便用于删除与添加元素，但不方便查找元素，因为每次都需要从前往后查找</p>
<p>数组方便查找，因为数组带有下标，但删除与增加元素不方便，每次修改元素都要重新修改下标</p>
<h3 id="链表的构造"><a href="#链表的构造" class="headerlink" title="链表的构造"></a>链表的构造</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-linkedlist.html">Java LinkedList | 菜鸟教程 (runoob.com)</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span></span>&#123;<br><br>	<span class="hljs-comment">//节点的值</span><br>	int <span class="hljs-keyword">val</span>;<br><br>	<span class="hljs-comment">//指向下一个节点</span><br>	ListNode next;<br><br>	<span class="hljs-comment">//无参构造函数</span><br>	<span class="hljs-keyword">public</span> ListNode()&#123;<br><br><br>	&#125;<br><br>	<span class="hljs-comment">//单参数的构造函数</span><br>	<span class="hljs-keyword">public</span> ListNode(int <span class="hljs-keyword">val</span>)&#123;<br>		<span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span>=<span class="hljs-keyword">val</span>;<br>	&#125;<br><br>	<span class="hljs-comment">//全参构造</span><br>	<span class="hljs-keyword">public</span> ListNode(int <span class="hljs-keyword">val</span>,ListNode next)&#123;<br>		<span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span>=<span class="hljs-keyword">val</span>;<br>		<span class="hljs-keyword">this</span>.next=next;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/submissions/">203. 移除链表元素 -  </a></p>
<p>前指针      后指针</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">虚拟头结点解法：先自定义一个头结点，让他的指针指向头部,然后再定义两个指针，一个指向虚拟头结点，一个指向真实头结点，</span><br><span class="hljs-comment">只要前面的结点指向不为空，就进行循环，循环的内容是判断前指针的值是否为要删除的值，</span><br><span class="hljs-comment">如果是要删除的值，就把前指针的下一个指向后指针的下一个指向，如果不等与，</span><br><span class="hljs-comment">就正常把后指针赋给前指针，意味着前后的顺序还是保持不变，然后就是每一轮循环后，都让后指针指向自己的后一个指针。</span><br><span class="hljs-comment">循环结束后，就返回虚拟头结点的下一个，因为要返回的是真实结点，添加虚拟头结点是为了处理第一个结点的删除问题</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/* 不添加虚拟解答的办法：</span><br><span class="hljs-comment">不添加虚拟结点，意味着头结点的删除，就不能依靠前指针的下一个指向后指针的下一个指向来解决问题，</span><br><span class="hljs-comment">这里就需要头结点的删除 做出特殊处理(直接让头结点指向下一个)，也就是头结点的值等于要删除的值。</span><br><span class="hljs-comment">除了头结点的其他值等于要删除的值，就可以按照前指针的下一个指向后指针的下一个指向来解决问题。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>注意</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> ListNode removeElements(ListNode head, int <span class="hljs-keyword">val</span>) &#123;<br><br>​       <span class="hljs-comment">//注意这里不适用if的原因是因为，可能出现了多个一样要删除的在一起</span><br>​        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">null</span> &amp;&amp; head.<span class="hljs-keyword">val</span>==<span class="hljs-keyword">val</span> )&#123;<br>​            head=head.next;<br>​        &#125;<br>​        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)&#123;<br>​            <span class="hljs-keyword">return</span> head;<br>​        &#125;<br>​        ListNode left=head;<br>​        ListNode right=head.next;<br>​        <span class="hljs-keyword">while</span>(right!=<span class="hljs-literal">null</span>)&#123;<br>​            <span class="hljs-keyword">if</span>(right.<span class="hljs-keyword">val</span>==<span class="hljs-keyword">val</span>)&#123;<br>​                left.next=right.next;<br>​            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>​                left=right;<br>​            &#125;<br>​            right=right.next;<br>​        &#125;<br>​         <span class="hljs-keyword">return</span> head;<br>​    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表 -  </a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">获取值：从头开始遍历链表，直到指针到了要找的位置就停止循环，然后返回这个指针位置的值</span><br><span class="hljs-comment">添加值：首先判断传入的指针位置是否大与链表的长度，如果是，就返回，意味着插入结束，如果存在小于0的数，</span><br><span class="hljs-comment">	就改变指针的位置为0，也就是从头开始插入，然后就开始让指针向前移动，直到找到要插入位置的前一结点。</span><br><span class="hljs-comment">	然后就把这个值的指针指向寻找指针的下一个，然后再把这个寻找指针的下一个指向要寻找的这个值，注意插入时长度加一。</span><br><span class="hljs-comment">添加头与添加尾：直接调用添加方法即可</span><br><span class="hljs-comment">删除：如果要删除的指针位置 在链表中，就删除，链表长度减一.如果没有就返回，代表删除结束。然后也是依次遍历。</span><br><span class="hljs-comment">	直到指针指向要删除的位置的前一个结点，就把这个位置的指针的下一个指向这个指针的下一个的下一个。</span><br><span class="hljs-comment">注意：删除和增加只需要找到要删除的前驱结点即可，然后执行删除与增加，而查找不同，必须要找到该查找结点</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/submissions/">206. 反转链表 -  </a></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/<span class="hljs-emphasis">*</span><br><span class="hljs-emphasis">思路：</span><br><span class="hljs-emphasis">双指针法，初始左指针指向空，右指针指向头部，开始循环，只要右指针指向不为空，就一直循环，</span><br><span class="hljs-emphasis">循环的内容就是左右指针向前移动，然后反转指针，先用另外一个临时指针把右指针的下一个指向存起来，</span><br><span class="hljs-emphasis">然后再把这个右指针的下一个指向传给左指针。</span><br><span class="hljs-emphasis">然后再从新给左指针取下一个位置即，右指针的位置，然后再给右指针重新给一个位置，即使之前保存的临时指针位置。</span><br><span class="hljs-emphasis">这里有点类似与两个数的交换，使用中间数进行存储</span><br><span class="hljs-emphasis">最后返回左指针即可</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">*</span><br></code></pre></td></tr></table></figure>



<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">/&#123;<br>        ListNode <span class="hljs-attribute">left</span>=<span class="hljs-literal">null</span>;<br>        ListNode <span class="hljs-attribute">right</span>=head;<br>        ListNode <span class="hljs-attribute">temp</span>=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(right!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-attribute">temp</span>=right.next;<br>            right.<span class="hljs-attribute">next</span>=left;<br><br>            <span class="hljs-attribute">left</span>=right;<br>            <span class="hljs-attribute">right</span>=temp;<br>        &#125;<br><br>        return left;<br></code></pre></td></tr></table></figure>

<h4 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">  <span class="hljs-comment">/* </span><br><span class="hljs-comment">    递归写法：</span><br><span class="hljs-comment">    递归思路其实就是双指指针的简化，具体简化为最后的左指针指向右指针，右指针指向下一个指针。</span><br><span class="hljs-comment">    递归的内容还是将前指针指向后指针的过程</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">public</span> ListNode reverse(ListNode left,ListNode right)&#123;<br>        ListNode <span class="hljs-keyword">temp</span>=<span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(right==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>         <span class="hljs-keyword">temp</span>=right.next;<br>         right.next=left;<br>       <span class="hljs-keyword">return</span> reverse(right,<span class="hljs-keyword">temp</span>);<br>    &#125;<br>    <span class="hljs-built_in">public</span> ListNode reverseList(ListNode head) &#123;        <br>      <span class="hljs-keyword">return</span>  reverse(<span class="hljs-keyword">null</span>,head);      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/submissions/">24. 两两交换链表中的节点 -  </a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">    迭代法：首先利用虚拟头结点处理头节点的删除问题，虚拟头结点指向头结点，</span><br><span class="hljs-comment">    最后返回的也是虚拟头结点的下一个结点。</span><br><span class="hljs-comment">    定义一个指针，指针指向虚拟头结点。然后进入循环，</span><br><span class="hljs-comment">    循环的条件是指针的下一个指向和下下个指向都不为空。循环的内容为，</span><br><span class="hljs-comment">    首先利用临时指针一存储指针的下一个指向，这样是为了方便后面的指针反转。</span><br><span class="hljs-comment">    然后再利用一个临时指针二存储指针的下下下个指向，</span><br><span class="hljs-comment">    这样是为了方便每一组数据交换后，方便与下一组的元素产生指针指向关系。</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    然后就将指针的下一个指向下下个指向，然后再将指针的下下个指向临时指针一，</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    然后再将指针的下下下个指向临时指针二，</span><br><span class="hljs-comment">    最后就将指针向前移动两个，最后返回即可</span><br><span class="hljs-comment">    */</span><br></code></pre></td></tr></table></figure>



<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs axapta">    <br><br>ListNode base=<span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);<br>base.<span class="hljs-keyword">next</span>=head;<br>ListNode current=base;<br><br>      <br><span class="hljs-keyword">while</span>(current.<span class="hljs-keyword">next</span>!=<span class="hljs-literal">null</span>&amp;&amp;current.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>!=<span class="hljs-literal">null</span>)&#123;<br>    <br>    ListNode temp=current.<span class="hljs-keyword">next</span>;<br>    ListNode temp1=current.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>    <br>    current.<span class="hljs-keyword">next</span>=current.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>    current.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>=temp;<br>    current.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>=temp1;<br><br>    current=current.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br><br><br>&#125;<br><span class="hljs-keyword">return</span> base.<span class="hljs-keyword">next</span>;<br><br><br></code></pre></td></tr></table></figure>

<p>删除倒数第n个结点</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/submissions/">19. 删除链表的倒数第 N 个结点 -  </a></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">/* <br>思路：双指针加上虚拟头节点，设置左右指针，先让右指针走<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>步，目的是为了保持与左指针的距离为<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>，<br>就是说当左指针指向为删除节点的前一个结点，而右指针指向为空，然后就将左指针下一个指向下下个指向<br><br><br>*/<br></code></pre></td></tr></table></figure>



<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* </span><br><span class="hljs-comment">      暴力解法：先便利整个链表，求出链表的长度，然后根据倒数的位置，求出正数的位置，然后再将指针便利到该位置的前一个，然后再将该位置的指针的下一个指向下下个</span><br><span class="hljs-comment">      </span><br><span class="hljs-comment">      */</span><br>      <span class="hljs-keyword">while</span>(p!=<span class="hljs-keyword">null</span>)&#123;<br>          p=p.<span class="hljs-keyword">next</span>;<br>          <span class="hljs-keyword">size</span>++;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(n==<span class="hljs-keyword">size</span>)&#123;<br>          <span class="hljs-keyword">return</span> head=head.<span class="hljs-keyword">next</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">int</span> index=<span class="hljs-keyword">size</span>-n;<br><br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;index-<span class="hljs-number">1</span>;i++)&#123;<br>          cur=cur.<span class="hljs-keyword">next</span>;<br><br>      &#125;<br>      cur.<span class="hljs-keyword">next</span>=cur.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>      <span class="hljs-keyword">return</span> head;<br><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/submissions/">面试题 02.07. 链表相交 -  </a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">为了解决两个链表长度不一致的问题，我们首先要求出两个链表长度的差值，让长的链表的指针先移动，</span><br><span class="hljs-comment">移动到差值的后一位，然后两个一起移动，只要两个指针的指向不相同，就一直移动到都为空，只要指向相同，</span><br><span class="hljs-comment">就立刻返回该节点。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode）</a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">思路：本题先要判断是否存在环，如果存在环，就需要求出入环的第一个结点，如果不存在环就直接返回。</span><br><span class="hljs-comment">判断是否存在环的方法是快慢指针法，慢指针依次走一步，快指针一次走两步，当快指针与满指针相遇就说明存在环，否则就不存在环。</span><br><span class="hljs-comment">找如何的结点的方法是，在头结点和相遇结点都定义一个指针，当两个指针相遇时，就是入环结点的位置了，具体原因设计数学问题。</span><br><span class="hljs-comment">注意数链表为空和为一的情况，都是不可能出现环的情况     </span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs routeros">public ListNode detectCycle(ListNode head) &#123;<br>     ListNode <span class="hljs-attribute">slow</span>=head;<br>     ListNode <span class="hljs-attribute">fast</span>=head;<br> <br>     <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span>&amp;&amp;fast.next!=<span class="hljs-literal">null</span>)&#123;<br>         <span class="hljs-attribute">fast</span>=fast.next.next;<br>         <span class="hljs-attribute">slow</span>=slow.next;<br><br>         <span class="hljs-keyword">if</span>(<span class="hljs-attribute">fast</span>==slow)&#123;<br><br>             break;<br>         &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-attribute">fast</span>==null || fast.<span class="hljs-attribute">next</span>==null)&#123;<br><br>            return <span class="hljs-literal">null</span>;<br>        &#125;<br>        ListNode <span class="hljs-attribute">index1</span>=head;<br>        ListNode <span class="hljs-attribute">index2</span>=fast;<br><br>        <span class="hljs-keyword">while</span>(index1!=index2)&#123;<br>            <span class="hljs-attribute">index1</span>=index1.next;<br>            <span class="hljs-attribute">index2</span>=index2.next;<br><br>        &#125;<br><br>        return index1;       <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素 - 力扣（LeetCode）</a></p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> ListNode removeElements(ListNode head, <span class="hljs-built_in">int</span> val) &#123;<br><br>       <span class="hljs-comment">/* </span><br><span class="hljs-comment">       双指针法：加上虚拟头结点，初始化做指针指向虚拟头结点，右指针指向头结点，只有右指针指向不为空，</span><br><span class="hljs-comment">       就一直移动，如果在移动的过程中，右指针指向的值是要删除的值，就将左指针的指向右指针的下一个，</span><br><span class="hljs-comment">       否则就将将左指针指向右指针，然后移动右指针为下一个</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       */</span><br><br>       ListNode base=<span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);<br>       base.<span class="hljs-keyword">next</span>=head;<br>       ListNode left=base;<br>       ListNode right=head;<br><br>       <span class="hljs-keyword">while</span>(right!=<span class="hljs-literal">null</span>)&#123;<br><br>           <span class="hljs-keyword">if</span>(right.val==val)&#123;<br>               left.<span class="hljs-keyword">next</span>=right.<span class="hljs-keyword">next</span>;<br><br><br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>                 left=right;<br>           &#125;<br><br><br>         <br>           right=right.<span class="hljs-keyword">next</span>;<br>       &#125;<br><br><br><br>       <span class="hljs-keyword">return</span> base.<span class="hljs-keyword">next</span>;<br><br>   &#125;<br></code></pre></td></tr></table></figure>



<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>一种可以类似于数组的数据结构，也就是可以通过下标访问元素的数据结构，但这里的下标并没有那么简单，这里的下标可以代表一些非整数型的值，为实现这种方法，就需要用到哈希函数，就是把非数值型通过计算哈希值得到下标值</p>
<h3 id="哈希值碰撞"><a href="#哈希值碰撞" class="headerlink" title="哈希值碰撞"></a>哈希值碰撞</h3><p>不同的对象的哈希值相同</p>
<p><strong>拉链法</strong>：</p>
<p><strong>线性探针法</strong>：</p>
<h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><p>常用于寻找某各元素</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>集合：无重复的</p>
<p>红黑树：一种平衡二叉搜索树，排过序的</p>
<h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/submissions/">242. 有效的字母异位词 -  </a></h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">     思路：首先考虑特殊情况，当两个字符串的长度不相等时，则一定不是异位词</span><br><span class="hljs-comment">     使用哈希表存储字符出现的次数，在s中字符出现就加一，在t中出现就减一，最后看哈希表中的值是否全为0，</span><br><span class="hljs-comment">     是就是异位词，反之则不是。</span><br><span class="hljs-comment">     </span><br><span class="hljs-comment">     */</span><br></code></pre></td></tr></table></figure>



<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Map&lt;Character,Integer&gt; map=<span class="hljs-keyword">new</span> HashMap&lt;Character,Integer&gt;<span class="hljs-literal">()</span>;<br><br>   <br>       <span class="hljs-built_in">int</span> l1=s.length<span class="hljs-literal">()</span>-<span class="hljs-number">1</span>;<br>       <span class="hljs-built_in">int</span> l2=t.length<span class="hljs-literal">()</span>-<span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">if</span>(l1!=l2)&#123;<br>           return <span class="hljs-literal">false</span>;<br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;=l1;i++)&#123;<br>           map.put(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>,map.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">i</span>)</span>,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>           map.put(t.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>,map.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">t</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">i</span>)</span>,<span class="hljs-number">0</span>)-<span class="hljs-number">1</span>);<br><br>       &#125;<br>       <span class="hljs-keyword">for</span>(Integer <span class="hljs-keyword">val</span>:map.values<span class="hljs-literal">()</span>)&#123;<br>           <span class="hljs-keyword">if</span>(<span class="hljs-keyword">val</span>!=<span class="hljs-number">0</span>)&#123;<br>               return <span class="hljs-literal">false</span>;<br>           &#125;<br>       &#125;<br>       return <span class="hljs-literal">true</span>;<br><br><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/submissions/">383. 赎金信 -  </a></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/*</span><br><span class="hljs-comment">思路：</span><br><span class="hljs-comment">使用一个哈希表记录元素的出现次数，字符再magezine出现加一，字符再ransomNote出现就减一，</span><br><span class="hljs-comment">统计完成后，就旁段该哈希表中的值是否有出现负数的，如果有就代表不能，反之则可能</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br>         Map&lt;Character,Integer&gt; map=<span class="hljs-keyword">new</span> HashMap&lt;Character,Integer&gt;<span class="hljs-literal">()</span>;<br><br>         <span class="hljs-built_in">int</span> l2=ransomNote.length<span class="hljs-literal">()</span>-<span class="hljs-number">1</span>;<br>         <span class="hljs-built_in">int</span> l1=magazine.length<span class="hljs-literal">()</span>-<span class="hljs-number">1</span>;<br>         <span class="hljs-keyword">if</span>(l2&gt;l1)&#123;<br>             return <span class="hljs-literal">false</span>;<br>         &#125;<br><br>         <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;=l1;i++)&#123;<br>             map.put(magazine.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>,map.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">magazine</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">i</span>)</span>,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br><br>         &#125;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;=l2;j++)&#123;<br>              map.put(ransomNote.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>,map.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">ransomNote</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">j</span>)</span>,<span class="hljs-number">0</span>)-<span class="hljs-number">1</span>);<br><br>         &#125;<br><br>         <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>:map.values<span class="hljs-literal">()</span>)&#123;<br><br>             <span class="hljs-keyword">if</span>(<span class="hljs-keyword">val</span>&lt;<span class="hljs-number">0</span>)&#123;<br>                 return <span class="hljs-literal">false</span>;<br>             &#125;<br>         &#125;<br><br>         return <span class="hljs-literal">true</span>;<br><br></code></pre></td></tr></table></figure>

<p>解法二</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/*使用数组进行记录：定义一个数组长度为26的数组 ,使用下标代表字符，得出下标的方式是num=&#x27;s&#x27;-&#x27;a&#x27;,</span><br><span class="hljs-comment">然后遍历两个字符串，记录字符的出现次数，ransomNote中出现减一，magzine中出现加一，最后遍历 该数组，</span><br><span class="hljs-comment">看是否有0出现</span><br><span class="hljs-comment">       */</span><br><br>       <span class="hljs-type">int</span>[] arr=<span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">26</span>];<br>       <span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> q=<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<br>           arr[i]=<span class="hljs-number">0</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;magazine.length();j++)&#123;<br>          p=magazine.charAt(j)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>           arr[p]++;<br>       &#125;<br><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;m&lt;ransomNote.length();m++)&#123;<br><br>           q=ransomNote.charAt(m)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>           arr[q]<span class="hljs-comment">--;</span><br><br>       &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;n&lt;<span class="hljs-number">26</span>;n++)&#123;<br>          <span class="hljs-keyword">if</span>(arr[n]&lt;<span class="hljs-number">0</span>)&#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>          &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br> <br></code></pre></td></tr></table></figure>

<h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/submissions/">49. 字母异位词分组 -  </a></h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">思路：利用哈希表进行存储，键为排序后的统一字符串，因为字母异位词的特点就是，排序后的字符顺序是一样的。<br>值就是，该键对应的一系列异位词，是一个列表。然后遍历整个字符数组，取出其中的每个字符串，变成字符数组，<br>然后排序，这样哈希表中的键就得到了，然后就把这个值放入一个列表中，这个列表就是哈希表中的值，如果这个值存在<br>就使用哈希表中已经存在的列表，不存在就创建一个新的，然后再把这个字符串放进去，最后就是将键值，放入哈希表中。<br>遍历结束后，最后就返回一个列表，值为哈希表的值<br></code></pre></td></tr></table></figure>

<h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/submissions/">438. 找到字符串中所有字母异位词 -  </a></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">使用滑动窗口，定义两个指针，一个做左指针，一个右指针，右指针先开始移动，负责窗口的右边界，而左指针负责收缩。<br>定义两个哈希表，一个用于记录我们需要的字符串p的字符记录，一个用于记录窗口内的可用字符记录。定义一个计数器，<br>用于记录满足条件的字符个数。定义一个列表用于返回的匹配到的异位词的下标。<br>进行循环时，取出右指针指向的值，只要右指针指向的值在我们需要的哈希表中，<br>就将该字符的窗口的哈希表进行添加或修改，如果需要的该字符记录和窗口内该字符的记录相等，就将计数器加一。<br>等到窗口值大小大于等于要匹配的字符串，就可以判断是否可以收缩了，如果计数器的次数与需求的哈希表长度一致，<br>就将左指针添加到该列表中，然后就是取出做指针的值，因为要缩小窗口了，如果左指针的值是我们需要的值，<br>就要改动该窗口中的字符的值和计数器的值。<br>等到循环结束后，返回列表即可<br>注意：<span class="hljs-keyword">equals</span>和<span class="hljs-operator">=</span><span class="hljs-operator">=</span>区别：<br>       在[<span class="hljs-number">-128</span>，<span class="hljs-number">127</span>]没有区别，超过这个区间就必须用<span class="hljs-keyword">equals</span>了，因为<span class="hljs-type">Integer</span>此时会创建两个对象。<br></code></pre></td></tr></table></figure>

<h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/submissions/">349. 两个数组的交集 -  </a></h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">/*<br>定义两个<span class="hljs-keyword">set</span>集合，一个用于存放结果集，一个用于去重其中的一个数组，取另外一个数组中的元素，<br>与转化后的去重数组元素进行比较，如果不在去重的<span class="hljs-keyword">set</span>中就进行下一次循环，如果在就将 该字符添加进结果集<br><br>*/<br></code></pre></td></tr></table></figure>

<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;<br><br><br>        HashSet&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-keyword">set</span>=<span class="hljs-built_in">new</span> HashSet&lt;<span class="hljs-type">Integer</span>&gt;();<br>        HashSet&lt;<span class="hljs-type">Integer</span>&gt; res=<span class="hljs-built_in">new</span> HashSet&lt;<span class="hljs-type">Integer</span>&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums1.length;i++)&#123;<br>            <span class="hljs-keyword">set</span>.<span class="hljs-keyword">add</span>(nums1[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums2.length;j++)&#123;<br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">set</span>.contains(nums2[j]))&#123;<br>                res.<span class="hljs-keyword">add</span>(nums2[j]);<br><br>            &#125;<br>        &#125;<br><br>        //将<span class="hljs-keyword">set</span>集合中的元素赋值给数组<br>        <span class="hljs-type">int</span> l=res.size();<br>       <span class="hljs-type">int</span>[] arr= <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[l];<br>       <span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:res)&#123;<br>            arr[m]=num;<br>            m++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> arr ;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/submissions/">350. 两个数组的交集 II -  </a></h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">思路：</span><br><span class="hljs-comment">定义一个哈希表用于记录两个字符中字符出现次数，在定义一个数组，用于存放最后结果。</span><br><span class="hljs-comment">然后取字符串一中的字符放入哈希表中，哈希值做加法，然后再取字符串二中的字符，</span><br><span class="hljs-comment">只要这个字符在之前的哈希表中存在且哈希值大于0，就做减法，然后再把这个键放入列表中</span><br><span class="hljs-comment">*/</span><br>        <br></code></pre></td></tr></table></figure>

<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">HashMap</span>&lt;Integer,Integer&gt; <span class="hljs-built_in">map</span>=<span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;Integer,Integer&gt;();<br>List&lt;Integer&gt; lists=<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br> <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;nums1.length;i++)&#123;<br><br>     <span class="hljs-built_in">map</span>.put(nums1[i],<span class="hljs-built_in">map</span>.getOrDefault(nums1[i],<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br><br> &#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>; j&lt;nums2.length;j++)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>.containsKey(nums2[j]) &amp;&amp; <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(nums2[j])&gt;<span class="hljs-number">0</span>)&#123;<br><br>        <span class="hljs-built_in">map</span>.put(nums2[j],<span class="hljs-built_in">map</span>.getOrDefault(nums2[j],<span class="hljs-number">0</span>)<span class="hljs-number">-1</span>);<br>        lists.<span class="hljs-built_in">add</span>(nums2[j]);<br><br><br>    &#125;     <br> &#125;<br><br> <span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span>=lists.<span class="hljs-built_in">size</span>();<br> <span class="hljs-built_in">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-built_in">size</span>];<br> <span class="hljs-built_in">int</span> p=<span class="hljs-number">0</span>;<br> <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> val:lists)&#123;<br>     arr[p]=val;<br>     p++;<br> &#125; <br> <span class="hljs-keyword">return</span> arr;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/submissions/">202. 快乐数 -  </a></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs applescript">/*<br>思路：<br>定义一个哈希<span class="hljs-keyword">set</span>,用于记录平方和是否在之前出现。当在无线循环中，出现了和为一的情况，就代表这个数是快乐数。<br>如果之前就出现了，就代表进入了循环，就直接返回<span class="hljs-literal">false</span>。否则将将该和插入到哈希表中。然后就将和赋值给n。<br>这里的重点就是，数字的各个位求和，这里单独定义一个函数，只要n&gt;<span class="hljs-number">0</span>就进行循环，然后使用求取各个位数相乘即可,<br>然后将数除以<span class="hljs-number">10</span>,循环结束然后返回该和。<br><br>*/<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/submissions/">1. 两数之和 -  </a></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">/*</span><br><span class="hljs-comment">       思路：使用一个哈希表进行记录我们访问过的元素，这样就不需要重复访问之前访问过的元素了，只要之前存在的元素被访问过且是我们需要差值元素，就返回该数组的下标位置，然后再返回对应的哈希值的值，如果不在我们的哈希表中，就将该值添加到哈希表中，继续进行下一次遍历。这里的哈希表键是数组的值，值是对应数字的下标。      </span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-keyword">HashMap</span>&lt;Integer,Integer&gt; <span class="hljs-built_in">map</span>=<span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;Integer,Integer&gt;();<br>       <span class="hljs-built_in">int</span> x=<span class="hljs-number">0</span>;<br>       <span class="hljs-built_in">int</span> y=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-built_in">int</span> le=target-nums[i];<br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>.containsKey(le))&#123;<br><br>                x=<span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(le);<br>                y=i;<br><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;x,y&#125;;<br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-built_in">map</span>.put(nums[i],i);<br>            &#125;<br><br><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/submissions/">454. 四数相加 II -  </a></h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">将四个数组两两一组，先计算一组的和，然后将该和作为键放入哈希表中，值就是该和出现的次数。然后就是要定义一个计数器，用于记录满足条件的数。</span><br><span class="hljs-comment">然后是在另外两个数组中，求和然后取相反数，然后就该值取找哈希表的值赋值给计数器，循环结束后，计数器得到的和也就是计数器反复累计的和，也就是最终总的个数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>



<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs fortran">HashMap&lt;<span class="hljs-keyword">Integer</span>,<span class="hljs-keyword">Integer</span>&gt; map=new HashMap&lt;<span class="hljs-keyword">Integer</span>,<span class="hljs-keyword">Integer</span>&gt;();<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span>=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span>;<br> for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;nums1.length;i++)&#123;<br><br>     for(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;nums2.length;j++)&#123;<br><br>         <span class="hljs-built_in">sum</span>=nums1[i]+nums2[j];<br>         map.put(<span class="hljs-built_in">sum</span>,map.getOrDefault(<span class="hljs-built_in">sum</span>,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br><br><br>     &#125;<br> &#125;<br><br> for(<span class="hljs-built_in">int</span> m=<span class="hljs-number">0</span>;m&lt;nums3.length;m++)&#123;<br><br>     for(<span class="hljs-built_in">int</span> n=<span class="hljs-number">0</span>;n&lt;nums4.length;n++)&#123;<br>         <span class="hljs-built_in">sum</span>=nums3[m]+nums4[n];<br><br>         <span class="hljs-keyword">if</span>(map.containsKey(-<span class="hljs-built_in">sum</span>))&#123;<br>            <span class="hljs-built_in">count</span>+= map.get(-<span class="hljs-built_in">sum</span>);<br>         &#125;<br><br>         <br>     &#125;<br> &#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>;<br><br><br><br></code></pre></td></tr></table></figure>



<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="**15. 三数之和 -  "></a>**<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/submissions/">15. 三数之和 -  </a></h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">思路：</span><br><span class="hljs-comment">注意，这里不重复的三元组是三个数完全相同，同时还有不能一个位置的元素用两次</span><br><span class="hljs-comment">先将数组排序，然后使用双指针方，定义三个指针，一个指向开头，用于遍历数组，一个左指针向开头的下一个，</span><br><span class="hljs-comment">而右指针指向数组的末尾。只要三个指针的和大于0，就移动右指针，小于0，就移动做指针，相等就将数组添加进数组.</span><br><span class="hljs-comment">注意这里要分别对三个数进行去重，只要出现过，就要跳过，也就是指针指针移动。</span><br><span class="hljs-comment">只要排完序后的某个位置的数大于0,后面的数也都不可能出现等于0的情况，所以返回之前的结果即可</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-built_in">int</span>[] nums) &#123;<br>        /*<br>        思路：<br>        注意，这里不重复的三元组是三个数完全相同，同时还有不能一个位置的元素用两次<br>        先将数组排序，然后使用双指针方，定义三个指针，一个指向开头，用于遍历数组，一个左指针向开头的下一个，而右指针指向数组的末尾。只要三个指针的和大于<span class="hljs-number">0</span>，就移动右指针，小于<span class="hljs-number">0</span>，就移动做指针，相等就将数组添加进数组.<br>        注意这里要分别对三个数进行去重，只要出现过，就要跳过，也就是指针指针移动。<br>        只要排完序后的某个位置的数大于<span class="hljs-number">0</span>,后面的数也都不可能出现等于<span class="hljs-number">0</span>的情况，所以返回之前的结果即可<br>      */<br>        Arrays.sort(nums);  <br>        <br>       <br>        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();<br><br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-built_in">if</span>(nums[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                return result;<br>            &#125;<br>            //对num[i]去重<br>            <span class="hljs-built_in">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i]==nums[i-<span class="hljs-number">1</span>])&#123;<br>                continue;<br><br>            &#125;<br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>=nums.length-<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>=i+<span class="hljs-number">1</span>;<br>            while(<span class="hljs-built_in">left</span>&lt;<span class="hljs-built_in">right</span>)&#123;  <br>                //注意这里的书写,直接写入时要加入上阔号<br>                <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>=nums[i]+nums[<span class="hljs-built_in">left</span>]+nums[<span class="hljs-built_in">right</span>];<br>                <span class="hljs-built_in">if</span>(<span class="hljs-built_in">sum</span>&gt;<span class="hljs-number">0</span>)&#123;<br>                   <span class="hljs-built_in">right</span>--;<br><br>                &#125;<br>                else <span class="hljs-built_in">if</span>(<span class="hljs-built_in">sum</span>&lt;<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-built_in">left</span>++;<br>                &#125;else&#123;<br><br>                    result.add(Arrays.asList(nums[i],nums[<span class="hljs-built_in">left</span>],nums[<span class="hljs-built_in">right</span>]));<br>                    //num[<span class="hljs-built_in">left</span>]和num[<span class="hljs-built_in">right</span>]去重<br>                    while(<span class="hljs-built_in">left</span>&lt;<span class="hljs-built_in">right</span> &amp;&amp; nums[<span class="hljs-built_in">left</span>]==nums[<span class="hljs-built_in">left</span>+<span class="hljs-number">1</span>])&#123;<br>                        <span class="hljs-built_in">left</span>++;<br><br>                    &#125;<br>                    while(<span class="hljs-built_in">left</span>&lt;<span class="hljs-built_in">right</span> &amp;&amp; nums[<span class="hljs-built_in">right</span>]==nums[<span class="hljs-built_in">right</span>-<span class="hljs-number">1</span>])&#123;<br>                        <span class="hljs-built_in">right</span>--;<br>                    &#125;<br>                    <span class="hljs-built_in">left</span>++;<br>                    <span class="hljs-built_in">right</span>--;<br><br><br>                &#125;<br><br>            &#125;<br>        &#125;<br><br><br>        return result;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">18. 四数之和 -  </a></h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">在三数之和的基础上再嵌套一层循环</span><br><span class="hljs-comment">首先要对数组进行排序Arrays.sort()</span><br><span class="hljs-comment">双指针法：定义两层循环，外层循环从0开始，内层循环在外层循环的下一层开始循环，然后就是左右指针</span><br><span class="hljs-comment">左指针指向内层循环的下一个，右指针指向末尾，只要四个数的和大于目标值，就将左右指针的值向前移动，反之，</span><br><span class="hljs-comment">就移动左指针指向的值，等于就将数组添加进结果集中，然后去重，分别在向中间移动，最后返回结果即可</span><br><span class="hljs-comment">这里依然可以进行剪枝操作，只要前两个数的0且和大于目标值，就意味后面的数没有满足条件地，就直接跳出本次循环</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>



<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public List&lt;List&lt;Integer&gt;&gt; four<span class="hljs-constructor">Sum(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">target</span>)</span> &#123;<br><br>       <br>        List&lt;List&lt;Integer&gt;&gt; res=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>sort(nums);<br>         <br><br>         <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br><br>             <span class="hljs-comment">//减枝</span><br>             <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>&gt;target)&#123;<br>                 break;<br>             &#125;<br><br>             <span class="hljs-comment">//去重</span><br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>==nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>-<span class="hljs-number">1</span>]</span>)&#123;<br>                continue;<br>            &#125;<br><br><br><br>             <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=i+<span class="hljs-number">1</span>;j&lt;nums.length;j++)&#123;<br><br>                 <span class="hljs-comment">//减枝</span><br>                 <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>+nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>+nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>&gt;target)&#123;<br>                     break;<br>                 &#125;<br><br>                 <span class="hljs-comment">//去重</span><br>                 <span class="hljs-keyword">if</span>(j&gt;i+<span class="hljs-number">1</span>&amp;&amp;nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>==nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>-<span class="hljs-number">1</span>]</span>)&#123;<br>                     continue;<br>                 &#125;<br>                 <span class="hljs-built_in">int</span> left=j+<span class="hljs-number">1</span>;<br>                 <span class="hljs-built_in">int</span> right=nums.length-<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br><br>                        <span class="hljs-built_in">int</span> sum=nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>+nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>+nums<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span>+nums<span class="hljs-literal">[<span class="hljs-identifier">right</span>]</span>;<br>                     <span class="hljs-keyword">if</span>(sum&gt;target)&#123;<br>                         right--;<br><br>                     &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&lt;target)&#123;<br>                         left++;<br><br>                     &#125;<span class="hljs-keyword">else</span>&#123;<br>                         res.add(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">nums</span>[<span class="hljs-params">i</span>],<span class="hljs-params">nums</span>[<span class="hljs-params">j</span>],<span class="hljs-params">nums</span>[<span class="hljs-params">left</span>],<span class="hljs-params">nums</span>[<span class="hljs-params">right</span>])</span>);<br><br>                     <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span>==nums<span class="hljs-literal">[<span class="hljs-identifier">left</span>+<span class="hljs-number">1</span>]</span>)&#123;left++;&#125;<br>                     <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums<span class="hljs-literal">[<span class="hljs-identifier">right</span>]</span>==nums<span class="hljs-literal">[<span class="hljs-identifier">right</span>-<span class="hljs-number">1</span>]</span>)&#123;right--;&#125;<br>                     <br>                     left++;<br>                     right--;<br><br>                 &#125;<br><br>                &#125;<br><br>             &#125;<br>         &#125;<br><br>         return res;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/submissions/">344. 反转字符串 -  </a></h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs excel">/*<br>      思路：<br>      定义两个指针，左指针指向开头，右指针指向尾部，然后交换这两个位置的数，交换结束后，指针同时向中间靠拢，<br>      只要直到左指针大于右指针就停止循环，然后返回数组即可<br>      <br>       */<br><br>       <span class="hljs-built_in">int</span> l=s.length;<br><br>       <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>=<span class="hljs-number">0</span>;<br>       <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>=l-<span class="hljs-number">1</span>;<br><br>       while(<span class="hljs-built_in">left</span>&lt;<span class="hljs-built_in">right</span>)&#123;<br>           <span class="hljs-built_in">char</span> temp;<br>          temp=s[<span class="hljs-built_in">left</span>];<br>          s[<span class="hljs-built_in">left</span>]=s[<span class="hljs-built_in">right</span>];<br>          s[<span class="hljs-built_in">right</span>]=temp;<br><br>          <span class="hljs-built_in">left</span>++;<br>          <span class="hljs-built_in">right</span>--;<br>           <br><br>       &#125;<br><br>   <br></code></pre></td></tr></table></figure>

<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs excel">/* <br>位运算交换*/<br><br>   <span class="hljs-built_in">int</span> l=s.length;<br><br>   <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>=<span class="hljs-number">0</span>;<br>   <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>=l-<span class="hljs-number">1</span>;<br><br>   while(<span class="hljs-built_in">left</span>&lt;<span class="hljs-built_in">right</span>)&#123;<br>      s[<span class="hljs-built_in">left</span>]^=s[<span class="hljs-built_in">right</span>];<br>      s[<span class="hljs-built_in">right</span>]^=s[<span class="hljs-built_in">left</span>];<br>      s[<span class="hljs-built_in">left</span>]^=s[<span class="hljs-built_in">right</span>];<br><br>      <span class="hljs-built_in">left</span>++;<br>      <span class="hljs-built_in">right</span>--;<br>       <br>   &#125;<br></code></pre></td></tr></table></figure>



<h3 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/submissions/">541. 反转字符串 II -  </a></h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">     思路：</span><br><span class="hljs-comment">     需注意，这里是每计数2k个字符，所以这里的固定区间就是2k,也就可以使用for循环</span><br><span class="hljs-comment">     这里只需要对每个2k区间的字符进行分析即可，对应的是两种情况</span><br><span class="hljs-comment">     第一种情况是：剩余字符大于k但小于2k,所以一次起始下标加上k就小于l,这里要处理的就是反转前k个字符</span><br><span class="hljs-comment">     第二种情况是：剩余字符小于k，所以最后一次起始下标加上k就大于l,全部交换</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     </span><br><span class="hljs-comment">     */</span><br></code></pre></td></tr></table></figure>



<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>    <span class="hljs-type">int</span> l=s.length();<br>    <span class="hljs-type">char</span>[] c=s.toCharArray();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i=i+<span class="hljs-number">2</span>*k)&#123;<br>        <span class="hljs-keyword">if</span>(i+k&lt;=l)&#123;<br><br>            reverse(c,i,i+k<span class="hljs-number">-1</span>);<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            reverse(c,i,l<span class="hljs-number">-1</span>);<br><br>        &#125;<br><br><br>    &#125;<br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> String(c);<br><br>&#125;<br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> reverse(<span class="hljs-type">char</span>[] s,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)&#123;<br><br>    <br>     <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>         <span class="hljs-type">char</span> <span class="hljs-keyword">temp</span>;<br>        <span class="hljs-keyword">temp</span>=s[left];<br>        s[left]=s[right];<br>        s[right]=<span class="hljs-keyword">temp</span>;<br><br>        left++;<br>        right<span class="hljs-comment">--;</span><br>         <br><br>     &#125;<br></code></pre></td></tr></table></figure>

<h3 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/submissions/">剑指 Offer 05. 替换空格 -  </a></h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">一个空格变成三个字符的过程中，增加了两个字符的长度，所以在进行字符替换前，先要对空格进行计数，</span><br><span class="hljs-comment">计算出要增加的长度</span><br><span class="hljs-comment">难点：将字符串变成增加长度的字符数组，</span><br><span class="hljs-comment">方法：先定义一个数组，长度为计算后的新增加长度，然后再把值赋给新数组</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">双指针法：定义两个指针，一个左指针，一个右指针，左指针指向新数组中源字符长度的位置，</span><br><span class="hljs-comment">而右指针指向新数组的末尾，</span><br><span class="hljs-comment">只要左指针遇到的不是空格，就将该值传递给右指针，遇到空格后，右指针给前面的位置一次赋值0,2,%,</span><br><span class="hljs-comment">然后左指针向前移动，</span><br><span class="hljs-comment">由此循环，直到，右边指针遇到左指针</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>



<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs haxe">char[] c=s.toCharArray();<br>int l=s.length();<br>int count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;l;i++)&#123;<br>    <span class="hljs-keyword">if</span>(s.charAt(i)==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>        count++;<br>    &#125;<br>&#125;<br>int len=l+count*<span class="hljs-number">2</span>;<br><br>char[] <span class="hljs-keyword">new</span><span class="hljs-type">s</span>=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len];<br><span class="hljs-keyword">for</span>(int j=<span class="hljs-number">0</span>;j&lt;l;j++)&#123;<br>    <span class="hljs-keyword">new</span><span class="hljs-type">s</span>[j]=c[j];<br>&#125;<br>int left=l<span class="hljs-number">-1</span>;<br>int right=len<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(left&lt;right)&#123;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span><span class="hljs-type">s</span>[left]!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">s</span>[right]=<span class="hljs-keyword">new</span><span class="hljs-type">s</span>[left];<br>        <br><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br><br>        <span class="hljs-keyword">new</span><span class="hljs-type">s</span>[right]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">s</span>[right<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;2&#x27;</span>;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">s</span>[right<span class="hljs-number">-2</span>]=<span class="hljs-string">&#x27;%&#x27;</span>;<br>        right-=<span class="hljs-number">2</span>;<br>    &#125;<br>    left--;<br>    right--;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(<span class="hljs-keyword">new</span><span class="hljs-type">s</span>);<br><br><br></code></pre></td></tr></table></figure>

<h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="**151. 反转字符串中的单词 -  "></a>**<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/submissions/">151. 反转字符串中的单词 -  </a></h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* 思路一：</span><br><span class="hljs-comment">        将单词以空格分割，然后再倒序连接字符串即可</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        */</span><br><br>        <span class="hljs-comment">//去除字符串开头和末尾的空白字符</span><br>        s=s.trim<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-comment">//分割字符串，连续匹配多个空白字</span><br>        List&lt;String&gt; lists=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">s</span>.<span class="hljs-params">split</span>(<span class="hljs-string">&quot;\\s+&quot;</span>)</span>);<br><br>        <span class="hljs-comment">//反转字符</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections</span>.</span></span>reverse(lists);<br><br>        <span class="hljs-comment">//拼接字符</span><br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>join(<span class="hljs-string">&quot; &quot;</span>,lists);<br></code></pre></td></tr></table></figure>



<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">      一共分为三个步奏：先将多余的空格给移除，然后反转整个字符串，最后反转每个单词。</span><br><span class="hljs-comment">      空格的移除可以使用快慢指针，快指针用于寻找不是空格的，慢指针指向空格，然后将快指针的值赋值给慢指针的值</span><br><span class="hljs-comment">      </span><br><span class="hljs-comment">      </span><br><span class="hljs-comment">      */</span><br></code></pre></td></tr></table></figure>



<h3 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/submissions/">剑指 Offer 58 - II. 左旋转字符串 -  </a></h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>        <span class="hljs-comment">/* </span><br><span class="hljs-comment">        思路一：利用额外开辟空间，先去除两个要旋转的字串，然后倒序追加到容器中即可</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">int</span> l=s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">String</span> s1=s.<span class="hljs-built_in">substring</span>(<span class="hljs-number">0</span>,n);<br>        <span class="hljs-keyword">String</span> s2=s.<span class="hljs-built_in">substring</span>(n,l);<br><br>        StringBuffer buf=<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuffer</span>();<br><br>        buf.<span class="hljs-built_in">append</span>(s2);<br>        buf.<span class="hljs-built_in">append</span>(s1);<br><br>        <span class="hljs-keyword">return</span> buf.<span class="hljs-built_in">toString</span>();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs excel">public String reverseLeftWords(String s, <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) &#123;<br><br>      /* <br>      思路二：<br>      不适用额外的空间，只是在原字符串上进行操作，<br>      先部分，后整体<br>      先将前后两部分的字符分别反转，然后再将整个字符串反转即可得到  =<br>      <br>      <br>      */<br>      <span class="hljs-built_in">int</span> l=s.length();<br>      <span class="hljs-built_in">char</span>[] c=s.toCharArray();<br>      reverses(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>);<br>      reverses(c,<span class="hljs-built_in">n</span>,l-<span class="hljs-number">1</span>);<br>      reverses(c,<span class="hljs-number">0</span>,l-<span class="hljs-number">1</span>);<br><br>      return new String(c);<br><br><br>      <br>  &#125;<br><br>  public void reverses(<span class="hljs-built_in">char</span>[] s ,<span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>,<span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>)&#123;<br>      <span class="hljs-built_in">char</span> temp;<br>      while(<span class="hljs-built_in">left</span>&lt;=<span class="hljs-built_in">right</span>)&#123;<br>          temp=s[<span class="hljs-built_in">left</span>];<br>          s[<span class="hljs-built_in">left</span>]=s[<span class="hljs-built_in">right</span>];<br>          s[<span class="hljs-built_in">right</span>]=temp;<br>          <span class="hljs-built_in">left</span>++;<br>          <span class="hljs-built_in">right</span>--;<br>        <br>      &#125;<br><br>  &#125;<br></code></pre></td></tr></table></figure>

<h3 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28. 找出字符串中第一个匹配项的下标 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标 -  </a></h3><p>解法一：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">/*</span><br><span class="hljs-comment">思路一：利用语言特性indexOf</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">return</span> haystack.<span class="hljs-title">indexOf</span><span class="hljs-params">(needle)</span></span>;<br></code></pre></td></tr></table></figure>

<p>解法二：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/*思路二：</span><br><span class="hljs-comment">       取长字符串中长度和段字符相等的进行计较，相等，就返回下标</span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">        */</span><br><br>        <span class="hljs-type">int</span> h=haystack.length();<br>        <span class="hljs-type">int</span> n=needle.length();<br>        <span class="hljs-keyword">if</span>(haystack.equals(needle))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(h&lt;n)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=h-n;i++)&#123;<br>            String s=haystack.substring(i,i+n);<br>            <span class="hljs-keyword">if</span>(s.equals(needle))&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br></code></pre></td></tr></table></figure>

<p>解法三：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-built_in">int</span> str<span class="hljs-constructor">Str(String <span class="hljs-params">haystack</span>, String <span class="hljs-params">needle</span>)</span> &#123;<br>    <br>  <span class="hljs-comment">/*KMP思想的实现：</span><br><span class="hljs-comment">  先要用一个next数组用于存储出现不匹配字符时，字符再一次匹配的位置，减少了每次都要从头开始匹配的次数。</span><br><span class="hljs-comment">  思想是。先遍历整个匹配字符串，求出每个字符前的最长匹配前后字符串。定义两个指针，左指针从0开始，右指针从1开始，只要前后指针不相等，就将左指针 的值赋值为next中左指针前一个位置的值，只要左右指针相等，就移动左指针，然后将左指针付给右指针代表的值。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  然后就是利用next素组进行遍字符串，思想与next类似，遍历整个字符串，也定义两个指针，左右指针都从0开始,只要左右指针代表的值不相等，就经左指针的值回滚到next数组中的左指针的前一个位置代表的指针，只要相等，就移动左指针，当左指针指匹配字符串的末尾时，就代表匹配完成，然后返回的起始坐标是左指针减去匹配的字符串的长度</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">   */</span>   <br>  <span class="hljs-keyword">if</span>(needle.length<span class="hljs-literal">()</span>==<span class="hljs-number">0</span>)&#123;<br>      return <span class="hljs-number">0</span>;<br>  &#125;<br>   <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> next=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">needle</span>.<span class="hljs-identifier">length</span>()]</span>;<br>   next(needle,next);<br>   <span class="hljs-built_in">int</span> left=<span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> right=<span class="hljs-number">0</span>;right&lt;haystack.length<span class="hljs-literal">()</span>;right++)&#123;<br>       <span class="hljs-keyword">while</span>(left&gt;<span class="hljs-number">0</span>&amp;&amp;haystack.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span>!=needle.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>)&#123;<br>           left=next<span class="hljs-literal">[<span class="hljs-identifier">left</span>-<span class="hljs-number">1</span>]</span>;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(haystack.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span>==needle.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>)&#123;<br>           left++;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(left==needle.length<span class="hljs-literal">()</span>)&#123;<br>           return (right-needle.length<span class="hljs-literal">()</span>+<span class="hljs-number">1</span>);<br>       &#125;<br><br>   &#125;<br>   return -<span class="hljs-number">1</span>; <br>  &#125;<br><br>  public void next( String needle,<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> arr)&#123;<br>      <span class="hljs-built_in">int</span> left=<span class="hljs-number">0</span>;<br>      arr<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>=<span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> right=<span class="hljs-number">1</span>;right&lt;needle.length<span class="hljs-literal">()</span>;right++)&#123;<br>          <span class="hljs-keyword">while</span>(left&gt;<span class="hljs-number">0</span>&amp;&amp;needle.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>!=needle.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span>)&#123;<br>              left=arr<span class="hljs-literal">[<span class="hljs-identifier">left</span>-<span class="hljs-number">1</span>]</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span>(needle.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>==needle.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span>)&#123;<br><br>              left++;<br>          &#125;<br>         arr<span class="hljs-literal">[<span class="hljs-identifier">right</span>]</span>=left;<br><br>      &#125;<br><br><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/submissions/">459. 重复的子字符串 -  </a></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/*</span><br><span class="hljs-comment">       移动匹配：将原字符串拼接为原来的两倍长，然后掐头去尾，然后在判断新字符串中是否包含原来的字符串，</span><br><span class="hljs-comment">       如果包含就说明原字符串是多次重复拼接而成的，反之则不是</span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">        */</span><br><br>        StringBuffer buf=<span class="hljs-built_in">new</span> StringBuffer();<br>        buf.<span class="hljs-built_in">append</span>(s);<br>        buf.<span class="hljs-built_in">append</span>(s);<br>        buf.<span class="hljs-built_in">delete</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        buf.<span class="hljs-built_in">delete</span>(buf.<span class="hljs-built_in">length</span>()-<span class="hljs-number">1</span>,buf.<span class="hljs-built_in">length</span>());<br>       <span class="hljs-keyword">if</span>(buf.indexOf(s)&gt;-<span class="hljs-number">1</span>)&#123;<br>           <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;<br><br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br><br></code></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">/* <br>当一个字符串是由重复字符串构成的，那他的长度一定可以被数组长度与最长前后缀的长度的差整除<br>KMP算法：先要计算出<span class="hljs-keyword">next</span>数组，一样的定义两个指针指针，左指针从<span class="hljs-number">0</span>开始，右指针从<span class="hljs-number">1</span>开始，遍历整个数组，<br>当数组的左右指针的值不相等时，就将<span class="hljs-keyword">next</span>数组中的左指针前一个指针指向的值赋值给左指针，<br>只要左右指针的值相等，就移动左指针，然后将左指针赋值给<span class="hljs-keyword">next</span>数组中的右指针的值。<br>只要最后<span class="hljs-keyword">next</span>数组长度的前一个值不为<span class="hljs-number">0</span>,且他的长度可以被长度与最长前后缀长度的差整除，就代表它可以是重复的，<br>反之则不是重复的<br><br>*/<br><br></code></pre></td></tr></table></figure>



<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">  public boolean repeated<span class="hljs-constructor">SubstringPattern(String <span class="hljs-params">s</span>)</span> &#123;<br>  <br>        <span class="hljs-built_in">int</span> len=s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)&#123;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> next=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">len</span>]</span>;<br>        next<span class="hljs-constructor">Int(<span class="hljs-params">s</span>,<span class="hljs-params">next</span>)</span>;<br>        <span class="hljs-keyword">if</span>(next<span class="hljs-literal">[<span class="hljs-identifier">len</span>-<span class="hljs-number">1</span>]</span>!=<span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>len%(len-(next<span class="hljs-literal">[<span class="hljs-identifier">len</span>-<span class="hljs-number">1</span>]</span>))==<span class="hljs-number">0</span>)&#123;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        return <span class="hljs-literal">false</span>;<br><br><br>       <br><br>&#125;<br><br>public void next<span class="hljs-constructor">Int(String <span class="hljs-params">s</span>,<span class="hljs-params">int</span>[] <span class="hljs-params">next</span>)</span>&#123;<br><br>    <span class="hljs-built_in">int</span> left=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> right=<span class="hljs-number">1</span>;right&lt;s.length<span class="hljs-literal">()</span>;right++)&#123;<br><br>        <span class="hljs-keyword">while</span>(left&gt;<span class="hljs-number">0</span>&amp;&amp;s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>!=s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span>)&#123;<br>            left=next<span class="hljs-literal">[<span class="hljs-identifier">left</span>-<span class="hljs-number">1</span>]</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>==s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span>)&#123;<br>            left++;<br>        &#125;<br>        next<span class="hljs-literal">[<span class="hljs-identifier">right</span>]</span>=left;<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h2><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/submissions/">27. 移除元素 -  </a></h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs excel">/*<br>       快慢指针法：定义两个指针，一个慢指针，一个快指针，快指针用于寻找不是要删除的元素，慢指针用于更新数组。<br>       遍历真个数组，只要快指针指向的值不等于要删除的值，就将快指针指向的值赋值给满指针的值，然后移动慢指针，。<br>       最后返回慢指针即可<br>       <br>       <br>        */<br><br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>=<span class="hljs-number">0</span>;<br>        for(<span class="hljs-built_in">int</span> fast=<span class="hljs-number">0</span>;fast&lt;nums.length;fast++)&#123;<br>            <span class="hljs-built_in">if</span>(nums[fast]!=val)&#123;<br>                nums[<span class="hljs-built_in">left</span>]=nums[fast];<br>                <span class="hljs-built_in">left</span>++;<br>            &#125;<br><br>        &#125;<br>        return <span class="hljs-built_in">left</span>;<br></code></pre></td></tr></table></figure>

<h3 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/submissions/">26. 删除有序数组中的重复项 -  </a></h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">       快慢指针法：定义两个指针，一个慢指针，一个快指针，慢指针用于更新数组，快指针用于找不重复的元素，然后直到快指针遍历到</span><br><span class="hljs-comment">       数组末尾，就返回慢指针的后一个即可，即去重后的数组长度.这里需要注意的是，每次都要先移动后赋值，为了避免多次覆盖同一个元素。</span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">       */</span><br></code></pre></td></tr></table></figure>

<h3 id="283-移动零-题解"><a href="#283-移动零-题解" class="headerlink" title="283. 移动零 题解 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/solution/">283. 移动零 题解 -  </a></h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">       双指针：</span><br><span class="hljs-comment">       快慢指针法：定义两个指针，一个慢指针，一个快指针，慢指针用于更新数组，快指针用于寻找不是0的元素，</span><br><span class="hljs-comment">       然后与慢指针进行</span><br><span class="hljs-comment">       交换，即可，直到快指针达到结尾</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">       */</span><br><br></code></pre></td></tr></table></figure>



<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int <span class="hljs-attribute">slow</span>=0;<br><br><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">fast</span>=0;fast&lt;nums.length;fast++)&#123;<br>    <span class="hljs-keyword">if</span>(nums[fast]!=0)&#123;<br>        int <span class="hljs-attribute">temp</span>=nums[fast];<br>        nums[fast]=nums[slow];<br>        nums[slow]=temp;<br>        slow++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串 -  </a></p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ada">/* <br> 思路：<br> 定义一个大循环，用于整体遍历两个数组，先遍历一个字符串，从后往看看哪些字符不被删除，<br> 遇到不被删除的字符就跳出，然后就去遍历另外一个字符串，也是寻找不删除的字符，<br> 然后比较这两个不被删除的字符，只要指针都大于<span class="hljs-number">0</span>且字符不相等，就直接返回<span class="hljs-literal">false</span>,只有其中一个大于<span class="hljs-number">0</span>，<br> 也返回<span class="hljs-literal">false</span>,然后移动两个指针，大循环借宿结束后，就可以返回<span class="hljs-literal">true</span>.<br>    <br> <br> <br> <br> */<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/submissions/">977. 有序数组的平方 -  </a></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs excel"> /*思路：<br>        定义一个和原数组长度一致的数组，用于记录平方后的排序结果，还有一个指针，这个指针指向末尾，用于存放元素组平方后较大的数。然后就是定义两个指针，一个左指针指向原数组的开头，一个右指针指向数组的结尾，然后进行循环比较这个两个指针平方后的值，只要<br>然后就把大的值赋给新数组，然后在移动这个指针和新数组的指针<br><br>        <br>         */<br><br>         <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span>=nums.length;<br>         <span class="hljs-built_in">int</span>[] res=new <span class="hljs-built_in">int</span>[<span class="hljs-built_in">len</span>];<br>         <span class="hljs-built_in">int</span> p=<span class="hljs-built_in">len</span>-<span class="hljs-number">1</span>;<br><br>         <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>=<span class="hljs-number">0</span>;<br>         <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>=<span class="hljs-built_in">len</span>-<span class="hljs-number">1</span>;<br>        <br>         while(<span class="hljs-built_in">left</span>&lt;=<span class="hljs-built_in">right</span>)&#123;<br>            <span class="hljs-built_in">if</span>(nums[<span class="hljs-built_in">left</span>]*nums[<span class="hljs-built_in">left</span>]&gt;nums[<span class="hljs-built_in">right</span>]*nums[<span class="hljs-built_in">right</span>])&#123;<br>                res[p]=nums[<span class="hljs-built_in">left</span>]*nums[<span class="hljs-built_in">left</span>];<br>                p--;<br>                <span class="hljs-built_in">left</span>++;<br>            &#125;else&#123;<br>                res[p]=nums[<span class="hljs-built_in">right</span>]*nums[<span class="hljs-built_in">right</span>];<br>                p--;<br>                <span class="hljs-built_in">right</span>--;<br>            &#125;<br><br><br><br>         &#125;<br><br>         return res; <br></code></pre></td></tr></table></figure>

<h3 id="344-反转字符串-1"><a href="#344-反转字符串-1" class="headerlink" title="344. 反转字符串 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/submissions/">344. 反转字符串 -  </a></h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs excel">/* <br>        思路：使用两个指针，一个指针指向开头，一个指针指向末尾，然后开始交换两个指针代表的元素，<br>        直到右指针的小于左指针就结束循环。<br>        */<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>=s.length-<span class="hljs-number">1</span>;<br>        <br>        while(<span class="hljs-built_in">left</span>&lt;<span class="hljs-built_in">right</span>)&#123;<br>            <span class="hljs-built_in">char</span> temp=s[<span class="hljs-built_in">right</span>];<br>            s[<span class="hljs-built_in">right</span>]=s[<span class="hljs-built_in">left</span>];<br>            s[<span class="hljs-built_in">left</span>]=temp;<br><br>            <span class="hljs-built_in">left</span>++;<br>            <span class="hljs-built_in">right</span>--;<br><br>        &#125;<br></code></pre></td></tr></table></figure>

<h3 id="剑指-Offer-05-替换空格-1"><a href="#剑指-Offer-05-替换空格-1" class="headerlink" title="剑指 Offer 05. 替换空格 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/submissions/">剑指 Offer 05. 替换空格 -  </a></h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs excel">/*<br>       思路：先遍历整个数组，计算空格的数量，然后申请一个新长度的数组，用于存储最终的结果。<br>       先将之前的字符串的部分映射到数组中，然后定义两个指针，一个左指针指向字符串的末尾，一个字符串指向新数组的末尾，<br>       然后左指针用于寻找不是空格的字符，然后将左指针的字符赋值给右指针，然后在移动右指针。<br>       如果遇到的是空格，就需要依次给右指针赋值<span class="hljs-number">02%</span>的字符，然后右指针移动三个·<br>       直到左指针指向开头，就结束，返回字符串<br>       <br>        */<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span>=<span class="hljs-number">0</span>;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>            <span class="hljs-built_in">if</span>(s.charAt(i)==&#x27; &#x27;)&#123;<br>               <span class="hljs-built_in">count</span>++;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span>=s.length()+<span class="hljs-built_in">count</span>*<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">char</span>[] res=new <span class="hljs-built_in">char</span>[<span class="hljs-built_in">len</span>];<br>        for(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;s.length();j++)&#123;<br>            res[j]=s.charAt(j);<br><br><br>        &#125;<br><br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>=s.length()-<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>=<span class="hljs-built_in">len</span>-<span class="hljs-number">1</span>;<br><br>        while(<span class="hljs-built_in">left</span>&gt;=<span class="hljs-number">0</span>)&#123;<br><br>            <span class="hljs-built_in">if</span>(res[<span class="hljs-built_in">left</span>]!=&#x27; &#x27;)&#123;<br>                res[<span class="hljs-built_in">right</span>]=res[<span class="hljs-built_in">left</span>];<br>                <span class="hljs-built_in">right</span>--;<br>                <span class="hljs-built_in">left</span>--;<br><br><br>            &#125;else&#123;<br>               res[<span class="hljs-built_in">right</span>]=&#x27;<span class="hljs-number">0</span>&#x27;;<br>               res[<span class="hljs-built_in">right</span>-<span class="hljs-number">1</span>]=&#x27;<span class="hljs-number">2</span>&#x27;;<br>               res[<span class="hljs-built_in">right</span>-<span class="hljs-number">2</span>]=&#x27;%&#x27;;<br><br>               <span class="hljs-built_in">right</span>=<span class="hljs-built_in">right</span>-<span class="hljs-number">3</span>;<br>               <span class="hljs-built_in">left</span>--;<br>            &#125;<br>        &#125;<br>        return new String(res);<br><br></code></pre></td></tr></table></figure>

<h3 id="151-反转字符串中的单词-1"><a href="#151-反转字符串中的单词-1" class="headerlink" title="151. 反转字符串中的单词 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词 -  </a></h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">整体思路：先反转整个字符串，然后反转每个单词。</span><br><span class="hljs-comment">细节问题：空格的去除，分为两边的空格和中间多余的空格。</span><br><span class="hljs-comment">需要一个容器</span><br><span class="hljs-comment">难点：中间多余空格的去除，目的是保留一个空格，只要从原字符中取出的字符不为空，</span><br><span class="hljs-comment">或则容器中的最后一个位置不为空格即可，因为只要两者都为空格时，才不会满足条件，</span><br><span class="hljs-comment">因为新容器中已经有了新的空格。</span><br><span class="hljs-comment">难点二：取出每个单词进行反转，定义两个指针，只要右指针指向空格，就反转左右指针区间的字符，</span><br><span class="hljs-comment">然后更新左指针为右指针的下一个，也就是空格的下一个，然后右指针在更新为左指针的下一个</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure>



<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* </span><br><span class="hljs-comment">   思想：先去除多余空格，然后再反转整个字符串，然后再反转其中的没一个单词</span><br><span class="hljs-comment">     去除空格分为三个步奏：先去除两端多余的空格，然后再去除单词中的多余空格，使得每个单词之间只有一个空格，</span><br><span class="hljs-comment">     具体方法是，建立一个可变容器，用于存放存放去除多余空格的字符串，然后就是建立两个指针，分别指向原字符串</span><br><span class="hljs-comment">     的头部和尾部，然后进行循环，只要头部指针不小于尾部指针，最先是同时移动首位指针，使得首尾指针指有字符的地方，然后就去</span><br><span class="hljs-comment">     去除中间的多余空格，如果源字符串的字符不为空格或则容器中的末尾不为空格，就将该字符添加到容器中，然后移动头指针</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     反转整个字符串，就是使用双指针即可，</span><br><span class="hljs-comment">     反转每个单词则涉及到找到每个单词区间，这几也是涉及用两个指针，只要右指针为空，就移动边的指针，就反转整个区间的单词，然后就更新</span><br><span class="hljs-comment">     左指针为右指针的前一个，右指针为左指针的下一个</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   */</span><br><br>   <span class="hljs-comment">//去除空格</span><br>   StringBuilder sb=remove<span class="hljs-constructor">Space(<span class="hljs-params">s</span>)</span>;<br><br>   <span class="hljs-comment">//反转整个字符串</span><br>   reverse<span class="hljs-constructor">String(<span class="hljs-params">sb</span>,0,<span class="hljs-params">sb</span>.<span class="hljs-params">length</span>()</span>-<span class="hljs-number">1</span>);<br><br><br>     <span class="hljs-comment">//反转每个字符</span><br>     reverse<span class="hljs-constructor">Words(<span class="hljs-params">sb</span>)</span>;<br><br> return <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">sb</span>)</span>;<br><br> &#125;<br><br> public void reverse<span class="hljs-constructor">Words(StringBuilder <span class="hljs-params">sb</span>)</span>&#123;<br>     <span class="hljs-built_in">int</span> left=<span class="hljs-number">0</span>;<br>     <span class="hljs-built_in">int</span> right=<span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">while</span>(left&lt;sb.length<span class="hljs-literal">()</span>)&#123;<br><br>         <span class="hljs-keyword">while</span>(right&lt;sb.length<span class="hljs-literal">()</span>&amp;&amp;sb.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span>!=<span class="hljs-character">&#x27; &#x27;</span>)&#123;<br>             right++;<br><br><br>         &#125;<br>         reverse<span class="hljs-constructor">String(<span class="hljs-params">sb</span>,<span class="hljs-params">left</span>,<span class="hljs-params">right</span>-1)</span>;<br><br>         left=right+<span class="hljs-number">1</span>;<br>         right=left+<span class="hljs-number">1</span>;<br><br><br>     &#125;<br><br><br> &#125;<br><br><br> public  void reverse<span class="hljs-constructor">String(StringBuilder <span class="hljs-params">sb</span>,<span class="hljs-params">int</span> <span class="hljs-params">left</span>,<span class="hljs-params">int</span> <span class="hljs-params">right</span>)</span>&#123;<br><br>     <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>         <span class="hljs-built_in">char</span> temp=sb.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span>;<br>         sb.set<span class="hljs-constructor">CharAt(<span class="hljs-params">right</span>,<span class="hljs-params">sb</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">left</span>)</span>);<br>         sb.set<span class="hljs-constructor">CharAt(<span class="hljs-params">left</span>,<span class="hljs-params">temp</span>)</span>;<br>         left++;<br>         right--;<br><br>     &#125;<br><br><br><br> &#125;<br><br> public StringBuilder remove<span class="hljs-constructor">Space(String <span class="hljs-params">s</span>)</span>&#123;<br><br>     <span class="hljs-built_in">int</span> left=<span class="hljs-number">0</span>;<br>     <span class="hljs-built_in">int</span> right=s.length<span class="hljs-literal">()</span>-<span class="hljs-number">1</span>;<br>     StringBuilder buf=<span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>     <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>==<span class="hljs-character">&#x27; &#x27;</span>)&#123;left++;&#125;<br>     <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span>==<span class="hljs-character">&#x27; &#x27;</span>)&#123;right--;&#125;<br>     <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>         <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>!=<span class="hljs-character">&#x27; &#x27;</span><span class="hljs-pattern-match"><span class="hljs-operator">||</span>buf.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">buf</span>.<span class="hljs-params">length</span>()</span>-1)!=&#x27; &#x27;)&#123;</span><br><span class="hljs-pattern-match">             buf.append(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>);</span><br><span class="hljs-pattern-match">         &#125;</span><br><span class="hljs-pattern-match">         left<span class="hljs-operator">++</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">     &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">     return buf;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"> &#125;</span><br><span class="hljs-pattern-match"></span><br></code></pre></td></tr></table></figure>

<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 -  </a></h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs coq">/* <br>      双指针法：定义两个指针，一个左指针，一个右指针，然后进行 循环，只要右指针指向不为空，就交换这个指针，进行反转<br>      <br>      */<br>      ListNode <span class="hljs-built_in">left</span>=null;<br>      ListNode <span class="hljs-built_in">right</span>=head;<br>      while(<span class="hljs-built_in">right</span>!=null)&#123;<br>          ListNode temp=<span class="hljs-built_in">right</span>.next;<br>          <span class="hljs-built_in">right</span>.next=<span class="hljs-built_in">left</span>;<br>          <span class="hljs-built_in">left</span>=<span class="hljs-built_in">right</span>;<br>          <span class="hljs-built_in">right</span>=temp;<br><br>      &#125;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">left</span>;<br><br><br></code></pre></td></tr></table></figure>

<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点 -  "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/submissions/">24. 两两交换链表中的节点 -  </a></h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> ListNode swapPairs(ListNode head) &#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这里需要定义一个虚拟头结点，指向头结点，然后在定义一个指针，指向虚拟头结点。这里将四个看成一组，带上头结点，这四个结点两两交换</span><br><span class="hljs-comment">        涉三个步奏，</span><br><span class="hljs-comment">        第一步让指针指向第二个结点：直接让指针的的下一个指向下下个</span><br><span class="hljs-comment">        第二部让第二个结点指向第一个结点：需要一个中间变量，存储下一个指针，然后将下下个指针指向中间变量</span><br><span class="hljs-comment">        第三步第一个结点指向三个结点：也需要一个中间变量，用于存储下下下个结点，然后将下下下个指向中间变量</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        指针移动到下下个。</span><br><span class="hljs-comment">        返回虚拟头结点的下一个</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">         */</span><br><br>         ListNode base=<span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);<br>         base.<span class="hljs-keyword">next</span>=head;<br>         ListNode cur=base;<br><br>         <span class="hljs-keyword">while</span>(cur.<span class="hljs-keyword">next</span>!=<span class="hljs-literal">null</span>&amp;&amp;cur.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>!=<span class="hljs-literal">null</span>)<br>         &#123;<br>             <span class="hljs-comment">//定义临时指针</span><br>             ListNode temp1=cur.<span class="hljs-keyword">next</span>;<br>             ListNode temp2=cur.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br><br>             <span class="hljs-comment">//第一步</span><br>             cur.<span class="hljs-keyword">next</span>=cur.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>             <span class="hljs-comment">//第二部</span><br>             cur.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>=temp1;<br>             <span class="hljs-comment">//第三步</span><br>            cur.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>=temp2;<br><br>            <span class="hljs-comment">//移动指针</span><br>            cur=cur.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br><br>         &#125;<br>         <span class="hljs-keyword">return</span> base.<span class="hljs-keyword">next</span>;<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点 "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/submissions/">19. 删除链表的倒数第 N 个结点 </a></h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/* </span><br><span class="hljs-comment">   思想：双指针，一个左指针，一个右指针，先让右指针走n+1步,</span><br><span class="hljs-comment">   y为了让右节点为空时，左指针刚好指向删除结点的前一。</span><br><span class="hljs-comment">   然后左右指针一起走，直到右指针为空，</span><br><span class="hljs-comment">   此时的左指针位置就是要删除结点的前一个，</span><br><span class="hljs-comment">   然后直接让这个指针指向下下个即可，</span><br><span class="hljs-comment">   为了避免头结点的删除问题，还是设置虚拟头结点</span><br><span class="hljs-comment">   </span><br><span class="hljs-comment">   */</span><br>   ListNode base=<span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);<br>   base.<span class="hljs-keyword">next</span>=head;<br>   ListNode left=base;<br>   ListNode right=base;<br><br>   <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>       <span class="hljs-keyword">if</span>(right==<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">break</span>;<br>       &#125;<br><br>       right=right.<span class="hljs-keyword">next</span>;<br>   &#125;<br><br>   <span class="hljs-keyword">while</span>(right!=<span class="hljs-literal">null</span>)&#123;<br>       left=left.<span class="hljs-keyword">next</span>;<br>       right=right.<span class="hljs-keyword">next</span>;<br>   &#125;<br><br>   left.<span class="hljs-keyword">next</span>=left.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br><br>   <span class="hljs-keyword">return</span> base.<span class="hljs-keyword">next</span>;<br><br><br></code></pre></td></tr></table></figure>

<h3 id="面试题-02-07-链表相交-力扣（LeetCode）"><a href="#面试题-02-07-链表相交-力扣（LeetCode）" class="headerlink" title="面试题 02.07. 链表相交 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/submissions/">面试题 02.07. 链表相交 - 力扣（LeetCode）</a></h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    先求出两个链表的长度，然后取出这两个链表长度的差值，求出差值的目的是，让链表长的先走，</span><br><span class="hljs-comment">    使得两个链表的距离交叉结点的距离一致，然后这两个链表的指针一起移动，</span><br><span class="hljs-comment">    当这个两个指针指向同一个结点时就输出该结点，如果等到两个指针都遍历结束了还没有找到，</span><br><span class="hljs-comment">    说明就没有相交的结点</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-keyword">int</span> lenA=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> lenB=<span class="hljs-number">0</span>;<br>    ListNode a=headA;<br>    ListNode b=headB;<br><br>    <span class="hljs-keyword">while</span>(a!=<span class="hljs-keyword">null</span>)&#123;<br>        lenA++;<br>        a=a.<span class="hljs-keyword">next</span>;<br><br>    &#125;<br>    <span class="hljs-keyword">while</span>(b!=<span class="hljs-keyword">null</span>)&#123;<br>        lenB++;<br>        b=b.<span class="hljs-keyword">next</span>;<br><br>    &#125;<br><br>    <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span>=lenA&gt;lenB?(lenA-lenB):(lenB-lenA);<br>    ListNode pointA=headA;<br>    ListNode pointB=headB;<br>    <span class="hljs-keyword">if</span>(lenA&gt;lenB)&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">size</span>&gt;<span class="hljs-number">0</span>)&#123;<br>            pointA=pointA.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-keyword">size</span>--;<br><br><br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>         <span class="hljs-keyword">while</span>(<span class="hljs-keyword">size</span>&gt;<span class="hljs-number">0</span>)&#123;<br>            pointB=pointB.<span class="hljs-keyword">next</span>;<br>            <span class="hljs-keyword">size</span>--;<br><br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(pointA!=<span class="hljs-keyword">null</span>&amp;&amp;pointB!=<span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(pointA==pointB)&#123;<br>            <span class="hljs-keyword">return</span> pointB;<br>        &#125;<br>         pointA=pointA.<span class="hljs-keyword">next</span>;<br>         pointB=pointB.<span class="hljs-keyword">next</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>   <br><br></code></pre></td></tr></table></figure>

<h3 id="142-环形链表-II-力扣（LeetCode）"><a href="#142-环形链表-II-力扣（LeetCode）" class="headerlink" title="142. 环形链表 II - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/submissions/">142. 环形链表 II - 力扣（LeetCode）</a></h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> ListNode detectCycle(ListNode head) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        使用快慢指针，快指针一次走两步，慢指针一次走一步，只要存在环，快慢指针就会在环中相遇，如果不存存在环，</span><br><span class="hljs-comment">        就一定会指向为空，快指针先移动，慢指针后移动，快慢指针相遇后，然后就是寻找入环结点，这里再定义两个结点，</span><br><span class="hljs-comment">        一个指向开头，一个指向相遇的结点，只要不相等就一直移动。注意：空结点和单个结点无环形成返回空</span><br><span class="hljs-comment">			然后返回相遇的结点即可</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">         */</span><br>        ListNode slow=head;<br>        ListNode fast=head;<br><br>        <span class="hljs-comment">//判断有没有环</span><br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span>&amp;&amp; fast.<span class="hljs-keyword">next</span>!=<span class="hljs-literal">null</span>)&#123;<br>            fast=fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>            slow=slow.<span class="hljs-keyword">next</span>;<br><br>            <span class="hljs-keyword">if</span>(fast==slow)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <br>        &#125;<br><br>        <span class="hljs-comment">//单独结点和空结点,无环,返回</span><br>        <span class="hljs-keyword">if</span>(fast==<span class="hljs-literal">null</span> || fast.<span class="hljs-keyword">next</span>==<span class="hljs-literal">null</span>)&#123;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//寻找环的入口</span><br>        ListNode index1=head;<br>        ListNode index2=fast;<br><br>        <span class="hljs-keyword">while</span>(index1!=index2)&#123;<br>            index1=index1.<span class="hljs-keyword">next</span>;<br>            index2=index2.<span class="hljs-keyword">next</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> index1;<br><br><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>栈是先进后出，添加与删除只能再栈顶进行，也就是说只在一端进行操作</p>
<p>队列是先进先出，删除只能在队尾进行，添加只能在队首进行</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/submissions/">232. 用栈实现队列 - 力扣（LeetCode）</a></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl">/*<br>思路：利用两个栈，分别记录队列的入栈操作与出栈记录。<br>因为栈是只在一段进行添加与删除，所以是先进后出，为了实现队列先进先出的规律，<br>需要先将入栈的栈顶弹出记录到出栈记录中，<br>然后出栈从栈顶弹出，相当于经过了一次反转，使得原本先进后出的栈变成了先进先出的队列。<br>每一次只要出栈记录中的元素为空，<br>经要将在入栈记录中的元素全部转移到出栈中，目的是保证队列的出栈顺序。<br><span class="hljs-keyword">push</span>就直接放入即可，<span class="hljs-keyword">pop</span>要判断出栈是否为空，不为空就直接将元素弹出即可，为空就要写入入栈的所有元素。<br>当出栈与入栈同时为空时，就表明队列为空了<br>注意：为空的要单独封装<br> */<br></code></pre></td></tr></table></figure>



<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;<br><br><br>        Stack&lt;Integer&gt; stackIn;<br>        Stack&lt;Integer&gt; stackOut;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">MyQueue</span>(<span class="hljs-params"></span>)</span> &#123;<br>        stackIn=<span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        stackOut=<span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">push</span>(<span class="hljs-params">int x</span>)</span> &#123;<br>        stackIn.push(x);<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123;<br>        stackpush();<br>        <span class="hljs-keyword">return</span> stackOut.pop();<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <br>        stackpush();<br>        <span class="hljs-keyword">return</span> stackOut.peek();<br><br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">empty</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>        <span class="hljs-keyword">return</span> stackIn.isEmpty()&amp;&amp;stackOut.isEmpty();<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">stackpush</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-keyword">if</span>(!stackOut.isEmpty())&#123;<span class="hljs-keyword">return</span>;&#125;<br>        <span class="hljs-keyword">while</span>(!stackIn.isEmpty())&#123;<br>            stackOut.push(stackIn.pop());<br>        &#125;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/submissions/">225. 用队列实现栈 - 力扣（LeetCode）</a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   出栈操作只需要将栈顶的元素弹出即可，而入栈需要反转顺序，为了实现后入先出的效果，</span><br><span class="hljs-comment">   需要用一个队列存储对应的栈顶前面的元素，因为栈顶先出队列，也就是最先压入栈顶的元素最先出栈。</span><br><span class="hljs-comment">   当队列为空的时就将存储的元素赋值给该队列，继续上一次的操作，即保留栈顶，然后出栈。</span><br><span class="hljs-comment">   </span><br><span class="hljs-comment">    */</span><br></code></pre></td></tr></table></figure>



<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">Queue&lt;Integer&gt; queue1;<br>Queue&lt;Integer&gt; queue2;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> </span>&#123;<br>    queue1=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    queue2=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">//元素放在辅助存储中</span><br>    queue2.offer(x);<br>    <span class="hljs-keyword">while</span>(!queue1.isEmpty())&#123;<br>        queue2.offer(queue1.poll());<br>    &#125;<br>    <span class="hljs-comment">//将辅助队列赋值给源队列,并且将辅助数组置为空</span><br>    Queue&lt;Integer&gt; queueTemp;<br>    queueTemp=queue1;<br>    queue1=queue2;<br>    queue2=queueTemp;<br><br>    <br><br><br>&#125;<br><span class="hljs-comment">//弹出栈顶</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> queue1.<span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br><span class="hljs-comment">//返回队尾</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> queue1.<span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> queue1.<span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/submissions/">20. 有效的括号 - 力扣（LeetCode）</a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  思想：</span><br><span class="hljs-comment">  使用栈的数据结构；先进后出，</span><br><span class="hljs-comment">  匹配不成功的三种情况：</span><br><span class="hljs-comment">  字符的个数为奇数的一定不能完全匹配。</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">  遍历最后的字符后，栈中还有元素，代表左边有多余的字符</span><br><span class="hljs-comment">  还没遍历完字符串，栈中就为空了，代表右边就为空了</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  遍历字符串，将字符中的左边部分放入栈中，当后面的右边部分字符与栈顶的元素匹配时，就将栈顶弹出，</span><br><span class="hljs-comment">  不相等就代表匹配失败。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">   */</span><br><br></code></pre></td></tr></table></figure>



<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span> </span>&#123;<br><br>  <br>         <span class="hljs-keyword">int</span> size=s.<span class="hljs-built_in">length</span>();<br><br>         <span class="hljs-comment">//字符个数为奇数匹配失败</span><br>         <span class="hljs-keyword">if</span>(size%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>         &#125;<br><br>         Stack&lt;Character&gt; stack=<span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br><br>             <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">charAt</span>(i)==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                 stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br><br>             &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">charAt</span>(i)==<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                 stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br><br><br>             &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">charAt</span>(i)==<span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>                 stack.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;]&#x27;</span>);<br><br>            <span class="hljs-comment">//匹配左括号不匹配或测栈提前为空</span><br>             &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">empty</span>()||stack.<span class="hljs-built_in">peek</span>()!=s.<span class="hljs-built_in">charAt</span>(i))&#123;<br><br>                     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>               <br>                 <br>            <span class="hljs-comment">//匹配成功，就将栈顶符号弹出</span><br>             &#125;<span class="hljs-keyword">else</span>&#123;<br>                 stack.<span class="hljs-built_in">pop</span>();<br><br>             &#125;<br><br><br>         &#125;<br><br>         <span class="hljs-comment">//遍历结束栈为空就代表匹配成功，反之则不成功</span><br><br>         <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">empty</span>();<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/submissions/">1047. 删除字符串中的所有相邻重复项 </a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">      思路：利用栈的先进后出的思想，和匹配口号的问题相似。先将元素放入栈中，以后后面的字符与栈顶不相等，</span><br><span class="hljs-comment">      就继续将元素放入</span><br><span class="hljs-comment">      栈中，只要相等，就弹出栈顶，且不将该字符插入到栈中，遍历结束后，将栈中元素返回即可</span><br><span class="hljs-comment">      最后注意：栈中弹出的元素时倒序的，需要反序才能得到正确答案</span><br><span class="hljs-comment">       */</span><br></code></pre></td></tr></table></figure>



<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public String remove<span class="hljs-constructor">Duplicates(String <span class="hljs-params">s</span>)</span> &#123;<br><br>      <br><br>         Stack&lt;Character&gt; statck=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Stack()</span>;<br><br>         <span class="hljs-built_in">int</span> size=s.length<span class="hljs-literal">()</span>;<br><br>         <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br><br><br>             <span class="hljs-keyword">if</span>(statck.empty<span class="hljs-literal">()</span><span class="hljs-pattern-match"><span class="hljs-operator">||</span>statck.peek()!=s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>)&#123;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">                statck.push(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>);</span><br><span class="hljs-pattern-match">             &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">                statck.pop();</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">             &#125;</span><br><span class="hljs-pattern-match">         &#125;</span><br><span class="hljs-pattern-match">        <span class="hljs-constructor">StringBuilder</span> sb=<span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;</span><br><span class="hljs-pattern-match">         <span class="hljs-keyword">while</span>(!statck.empty())&#123;</span><br><span class="hljs-pattern-match">             sb.append(statck.pop());</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">         &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">    </span><br><span class="hljs-pattern-match">        sb.reverse();</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">         return <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">sb</span>)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/submissions/">150. 逆波兰表达式求值 - 力扣（LeetCode）</a></p>
<p> /*<br>        定义一个栈：<br>        将字符数组的压入栈中，遇到数字就压入栈顶，遇到运算符号就进把栈尾的两个数进行运算然后压入栈中，<br>        直到循环结束<br>        返回栈顶元素。注意运算的时候的顺序是前面的在前，后面的在后，也就是先出来的在后面</p>
<p>Integer.valueOf 转换字符为数字</p>
<p> */</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><br>Stack&lt;Integer&gt; stack=<span class="hljs-built_in">new</span> Stack();<br>int size=<span class="hljs-built_in">tokens</span>.<span class="hljs-built_in">length</span>;<br>int result=<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">tokens</span>[i].equals(<span class="hljs-string">&quot;+&quot;</span>))&#123;<br>        result=stack.<span class="hljs-built_in">pop</span>();<br>        result+=stack.<span class="hljs-built_in">pop</span>();<br>        stack.<span class="hljs-built_in">push</span>(result);<br><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">tokens</span>[i].equals(<span class="hljs-string">&quot;-&quot;</span>))&#123;<br>        result=stack.<span class="hljs-built_in">pop</span>();<br>        result=stack.<span class="hljs-built_in">pop</span>()-result;<br>        stack.<span class="hljs-built_in">push</span>(result);<br><br><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">tokens</span>[i].equals(<span class="hljs-string">&quot;*&quot;</span>))&#123;<br>        result=stack.<span class="hljs-built_in">pop</span>();<br>        result=stack.<span class="hljs-built_in">pop</span>()*result;<br>        stack.<span class="hljs-built_in">push</span>(result);<br><br>        <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">tokens</span>[i].equals(<span class="hljs-string">&quot;/&quot;</span>))&#123;<br>        result=stack.<span class="hljs-built_in">pop</span>();<br>        result=stack.<span class="hljs-built_in">pop</span>()/result;<br>        stack.<span class="hljs-built_in">push</span>(result);<br><br>        <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        stack.<span class="hljs-built_in">push</span>(Integer.valueOf(<span class="hljs-built_in">tokens</span>[i]));<br><br>    &#125;<br><br><br>&#125;<br><span class="hljs-built_in">return</span> stack.<span class="hljs-built_in">pop</span>();<br><br><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/submissions/">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     利用队列的用于取出窗口内的最大值，队列内保持从大到小的顺序，这样方便每一移动一次窗口，</span><br><span class="hljs-comment">     就可以从队列中取得窗口中的最大值。</span><br><span class="hljs-comment">     自定义一个队列，实现如下功能：</span><br><span class="hljs-comment">     保持队列从大到小的方法：每次将窗口内的新增的值放入时，判断是否大于队列头部的值，</span><br><span class="hljs-comment">     如果大于，就弹出队列头部的值，直到队列头部大于该值。</span><br><span class="hljs-comment">     如果移动窗口出去的值和队列中的尾部的值相同，就移除尾部。</span><br><span class="hljs-comment">     </span><br><span class="hljs-comment">      */</span><br></code></pre></td></tr></table></figure>



<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] <span class="hljs-built_in">maxSlidingWindow</span>(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br><br>     <br>         <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">1</span>)&#123;<br>             <span class="hljs-keyword">return</span> nums;<br>         &#125;<br><br>         <span class="hljs-comment">//定义返回结果的数组长度</span><br>         <span class="hljs-keyword">int</span> len=nums.length-k+<span class="hljs-number">1</span>;<br>         <span class="hljs-keyword">int</span>[] res=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>         <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;<span class="hljs-comment">//用于记录存放的结果序号</span><br><br>         <span class="hljs-comment">//定义自定义的单调队列</span><br>         MyQueue que=<span class="hljs-keyword">new</span> <span class="hljs-built_in">MyQueue</span>();<br><br>         <span class="hljs-comment">//才开始的时候，先将k个元素放入栈中</span><br>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>             que.<span class="hljs-built_in">add</span>(nums[i]);<br>         &#125;<br>        res[num++]=que.<span class="hljs-built_in">peek</span>();<br><br>         <span class="hljs-comment">//开始移动窗口，</span><br><br>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=k;j&lt;nums.length;j++)&#123;<br>             <span class="hljs-comment">//判断队尾元素是否该移除</span><br>             que.<span class="hljs-built_in">poll</span>(nums[j-k]);<br>             <span class="hljs-comment">//放入新的值</span><br>             que.<span class="hljs-built_in">add</span>(nums[j]);<br><br>             <span class="hljs-comment">//返回队列尾部的最大值</span><br>             res[num++]=que.<span class="hljs-built_in">peek</span>();<br>         &#125;<br><br>         <span class="hljs-keyword">return</span> res;<br>        <br><br><br><br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span>&#123;</span><br>        <span class="hljs-comment">//双端队列，队头和队尾都可以插入和删除</span><br><br>       Deque&lt;Integer&gt; deque=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>       <span class="hljs-comment">//模拟弹出队尾元素，当窗口弹出值和队列尾部值相等时</span><br>       <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>           <span class="hljs-keyword">if</span>(!deque.<span class="hljs-built_in">isEmpty</span>()&amp;&amp;val==deque.<span class="hljs-built_in">peek</span>())&#123;<br>               deque.<span class="hljs-built_in">poll</span>();<br>           &#125;<br>       &#125;<br>        <span class="hljs-comment">//模拟实现，添加功能，需要判断添加的元素和队列头部的值，如果大于就移除头部的值，直到头部的值大于等于添加的值,然后添加该值</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>            <span class="hljs-keyword">while</span>(!deque.<span class="hljs-built_in">isEmpty</span>()&amp;&amp;val&gt;deque.<span class="hljs-built_in">getLast</span>())&#123;<br>                deque.<span class="hljs-built_in">removeLast</span>();<br>            &#125;<br>            deque.<span class="hljs-built_in">add</span>(val);<br>        &#125;<br>        <span class="hljs-comment">//取出队尾的最大值</span><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> deque.<span class="hljs-built_in">peek</span>();<br>        &#125;<br><br>    <br><br>      <br>&#125;<br></code></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/submissions/">347. 前 K 个高频元素 - 力扣（LeetCode）</a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*先利用hashmap去记录数组中字符出现的次数，然后将map的键值关系放入到一个优先级队列中</span><br><span class="hljs-comment">      （按照值从小到到大排序），如果队列中的元素个数大于了K,就直接弹出队尾元素，</span><br><span class="hljs-comment">      最后倒序取出值放入到数组中返回即可</span><br><span class="hljs-comment">       */</span><br></code></pre></td></tr></table></figure>



<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs lasso">  <br><br>    <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Integer</span>,<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">map</span>=<span class="hljs-literal">new</span> HashMap&lt;&gt;();<br>    for(<span class="hljs-built_in">Integer</span> num:nums)&#123;<br>        <span class="hljs-built_in">map</span>.put(num,<span class="hljs-built_in">map</span>.getOrDefault(num,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//建立优先级队列，并重写比较器</span><br>    PriorityQueue&lt;<span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">Integer</span>,<span class="hljs-built_in">Integer</span>&gt;&gt; pq=<span class="hljs-literal">new</span> PriorityQueue&lt;&gt;((entry1,entry2)-&gt;&#123;<br>        <span class="hljs-comment">//按map照键值对中的值进行排序</span><br>        <span class="hljs-keyword">return</span> entry1.getValue().compareTo(entry2.getValue());<br>    &#125;);<br><br>    <span class="hljs-comment">//建立迭代器,entry键值关系</span><br>    for(<span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">Integer</span>,<span class="hljs-built_in">Integer</span>&gt; entry:<span class="hljs-built_in">map</span>.entrySet())&#123;<br><br>        pq.add(entry);<br><br>        <span class="hljs-keyword">if</span>(pq.size()&gt;k)&#123;<br>            pq.poll();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//倒序遍历出结果</span><br>    int<span class="hljs-meta">[</span><span class="hljs-meta">]</span> res=new int<span class="hljs-meta">[</span>k<span class="hljs-meta">]</span>;<br>    for(int i=k-1;i&gt;=0;i--)&#123;<br>        res<span class="hljs-meta">[</span>i<span class="hljs-meta">]</span>=pq.poll().getKey();<br>    &#125;<br><br>    return res;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/submissions/">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] <span class="hljs-built_in">maxSlidingWindow</span>(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这里需要自己定义一个队列，用于实现对应的单调队列的操作 add,poll,peek</span><br><span class="hljs-comment">        利用队列的用于取出窗口内的最大值，队列内保持从大到小的顺序，这样方便每一移动一次窗口，</span><br><span class="hljs-comment">        就可以从队列中取得窗口中的最大值。</span><br><span class="hljs-comment">        保持队列从大到小的方法：每次将窗口内的新增的值放入时，判断是否大于队列头部的值，如果大于，</span><br><span class="hljs-comment">        就弹出队列头部的值，直到队列头部大于该值。</span><br><span class="hljs-comment">        如果移动窗口出去的值和队列中的尾部的值相同，就移除尾部。</span><br><span class="hljs-comment">        当数组只有一个元素时，就代表他就是最大值</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums;<br>        &#125;<br><br>         myque que=<span class="hljs-keyword">new</span> <span class="hljs-built_in">myque</span>();<br><br>         <span class="hljs-comment">//定义返回数组</span><br>         <span class="hljs-keyword">int</span> len=nums.length-k+<span class="hljs-number">1</span>;<br>         <span class="hljs-keyword">int</span>[] res=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>         <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br><br>         <span class="hljs-comment">//先将前k个元素放进队列中</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            que.<span class="hljs-built_in">add</span>(nums[i]);<br>        &#125;<br>        res[count++]=que.<span class="hljs-built_in">peek</span>();<br><br>        <span class="hljs-comment">//开始移动窗口</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=k;j&lt;nums.length;j++)&#123;<br>            <br>            que.<span class="hljs-built_in">poll</span>(nums[j-k]);<br>            que.<span class="hljs-built_in">add</span>(nums[j]);<br>            <br><br>            res[count++]=que.<span class="hljs-built_in">peek</span>();<br><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br><br><br><br>        <br>    &#125;   <br><br>      <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myque</span>&#123;</span><br>    Deque&lt;Integer&gt; deque=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(!deque.<span class="hljs-built_in">isEmpty</span>()&amp;&amp;val&gt;deque.<span class="hljs-built_in">getLast</span>())<br>        &#123;<br><br>            deque.<span class="hljs-built_in">removeLast</span>();<br>        &#125;<br>        deque.<span class="hljs-built_in">add</span>(val);<br><br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!deque.<span class="hljs-built_in">isEmpty</span>()&amp;&amp;deque.<span class="hljs-built_in">peek</span>()==val)&#123;<br>            deque.<span class="hljs-built_in">poll</span>();<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-keyword">return</span> deque.<span class="hljs-built_in">peek</span>();<br><br><br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/submissions/">232. 用栈实现队列 - 力扣（LeetCode）</a></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/* </span><br><span class="hljs-comment">   利用两个栈模拟队列的先进先出，只需要用一个栈表示入栈，一个队列表示出栈即可。队列的删除,当出栈不为空时，直接从出栈中弹出即可 ，当出栈为空时，就要将入栈的元素弹出压出出栈。队列的入队，直接压入入栈即可</span><br><span class="hljs-comment">   </span><br><span class="hljs-comment">   */</span><br>    Stack&lt;Integer&gt; stackIn;<br>    Stack&lt;Integer&gt; stackOut;<br><br>   <span class="hljs-keyword">public</span> MyQueue() &#123;<br>       stackIn=<span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>       stackOut=<span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">push</span>(<span class="hljs-keyword">int</span> x) &#123;<br>       stackIn.<span class="hljs-keyword">push</span>(x);<br><br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">pop</span>() &#123;<br>       <span class="hljs-keyword">if</span>(!stackOut.isEmpty())&#123;<br>         <span class="hljs-keyword">return</span> stackOut.<span class="hljs-keyword">pop</span>();<br><br><br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-keyword">while</span>(!stackIn.isEmpty())&#123;<br>           <span class="hljs-keyword">int</span> nums= stackIn.<span class="hljs-keyword">pop</span>();<br>           stackOut.<span class="hljs-keyword">push</span>(nums);<br><br>           &#125;           <br>       &#125;<br><br>       <span class="hljs-keyword">return</span> stackOut.<span class="hljs-keyword">pop</span>();<br><br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> peek() &#123;<br><br>       <span class="hljs-keyword">if</span>(stackOut.isEmpty())&#123;<br>           <span class="hljs-keyword">while</span>(!stackIn.isEmpty())&#123;<br>           <span class="hljs-keyword">int</span> nums= stackIn.<span class="hljs-keyword">pop</span>();<br>           stackOut.<span class="hljs-keyword">push</span>(nums);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> stackOut.peek();<br><br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> empty() &#123;<br><br>       <span class="hljs-keyword">if</span>(stackIn.isEmpty()&amp;&amp;stackOut.isEmpty())&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>   &#125;<br></code></pre></td></tr></table></figure>



<h2 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h2><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>除了最后一层没有填满，其余层都填满了，最后一层的结点优先从左往右排，如果存在左边没有排满就排右边，就不是完全二叉树</p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>只有度数为0和2的结点，0度结点都在同一层上，满足深度为k的慢二叉树，一共就有2的k次方-1个节点</p>
<h4 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h4><p>满足左子树的值小于根节点，右子树的值大于根节点的值，且左右子树的高度差不超过一</p>
<h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p>先遍历到叶节点，再往回遍历</p>
<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>先遍历完一层后，才遍历下一层</p>
<h4 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h4><p>链式存储：使用左右指实现</p>
<p>数组存储：直接根据数组的下标与节点对应，然后将节点的值存储到数组中</p>
<h3 id="二叉树的构造"><a href="#二叉树的构造" class="headerlink" title="二叉树的构造"></a>二叉树的构造</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    int <span class="hljs-keyword">val</span>;<br>  	TreeNode left;<br>  	TreeNode right;<br>  	TreeNode() &#123;&#125;<br>  	TreeNode(int <span class="hljs-keyword">val</span>) &#123; <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>; &#125;<br>  	TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br>    		<span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>    		<span class="hljs-keyword">this</span>.left = left;<br>    		<span class="hljs-keyword">this</span>.right = right;<br>  	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="递归写法-1"><a href="#递归写法-1" class="headerlink" title="递归写法"></a>递归写法</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/submissions/">144. 二叉树的前序遍历 </a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">**<br> * Definition <span class="hljs-keyword">for</span> a binary tree node.<br> * <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br> *     int <span class="hljs-keyword">val</span>;<br> *     TreeNode left;<br> *     TreeNode right;<br> *     TreeNode() &#123;&#125;<br> *     TreeNode(int <span class="hljs-keyword">val</span>) &#123; <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>; &#125;<br> *     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br> *         <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br> *         <span class="hljs-keyword">this</span>.left = left;<br> *         <span class="hljs-keyword">this</span>.right = right;<br> *     &#125;<br> * &#125;<br> */<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        递归法</span><br><span class="hljs-comment">        1.确定传入参数和返回值类型</span><br><span class="hljs-comment">        2.确定终止条件</span><br><span class="hljs-comment">        3.确定单层出来逻辑</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">         */</span><br><br>        List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); <br>        qianxv(root,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> void qianxv(TreeNode node,List&lt;Integer&gt; res)&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        res.add(node.<span class="hljs-keyword">val</span>);<br>        qianxv(node.left,res);<br>        qianxv(node.right,res);<br><br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/submissions/">145. 二叉树的后序遍历 </a></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> List&lt;<span class="hljs-type">Integer</span>&gt; postorderTraversal(TreeNode root) &#123;<br>        List&lt;<span class="hljs-type">Integer</span>&gt; res=<span class="hljs-built_in">new</span> ArrayList&lt;<span class="hljs-type">Integer</span>&gt;();<br>        houxv(root,res);<br>        <span class="hljs-keyword">return</span> res;<br><br><br><br>    &#125;<br><br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> houxv(TreeNode node,List&lt;<span class="hljs-type">Integer</span>&gt; res)&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        houxv(node.left,res);<br>        houxv(node.right,res);<br>        res.<span class="hljs-keyword">add</span>(node.val);<br><br><br><br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/submissions/">94. 二叉树的中序遍历</a></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> List&lt;<span class="hljs-type">Integer</span>&gt; inorderTraversal(TreeNode root) &#123;<br><br>        List&lt;<span class="hljs-type">Integer</span>&gt; res=<span class="hljs-built_in">new</span> ArrayList&lt;<span class="hljs-type">Integer</span>&gt;();<br>        zhongxv(root,res);<br>        <span class="hljs-keyword">return</span> res;<br><br><br><br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> zhongxv(TreeNode node,List&lt;<span class="hljs-type">Integer</span>&gt; res)&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        zhongxv(node.left,res);<br>        res.<span class="hljs-keyword">add</span>(node.val);<br>        zhongxv(node.right,res);<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/submissions/">144. 二叉树的前序遍历 </a></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; preorderTraversal(TreeNode root) &#123;<br><br>      <span class="hljs-comment">/* </span><br><span class="hljs-comment">      使用栈进行中间存储转换：顺序为中，右，左，出栈之后的顺序就变成了中左右</span><br><span class="hljs-comment">      只要左右结点不为空，就放入 栈中，然后依次弹出栈顶即可,注意空二叉树的情况</span><br><span class="hljs-comment">      */</span><br><br>      <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span>=<span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;&gt;();<br>      <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; res=<span class="hljs-literal">new</span> ArrayList&lt;&gt;();<br>      <span class="hljs-keyword">if</span>(root==<span class="hljs-built_in">null</span>)&#123;<br>          <span class="hljs-keyword">return</span> res;<br>      &#125;<br>      <span class="hljs-built_in">stack</span>.push(root);<br><br>      <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">stack</span>.isEmpty())&#123;<br>          <span class="hljs-comment">//弹出栈</span><br>          TreeNode node=<span class="hljs-built_in">stack</span>.pop();<br>          res.add(node.val);<br><br><br>          <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-built_in">null</span>)&#123;<br>              <span class="hljs-built_in">stack</span>.push(node.right);<br>              <br>          &#125;<br>          <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-built_in">null</span>)&#123;<br>               <span class="hljs-built_in">stack</span>.push(node.left);<br><br>          &#125;<br><br>      &#125;<br><br>      <span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; inorderTraversal(TreeNode root) &#123;<br><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   迭代法：</span><br><span class="hljs-comment">   与前序遍历不同的是，中序遍历访问的节点与处理的节点不是同一个，需要单独进行处理，定义一个指针，</span><br><span class="hljs-comment">   用于判断是否到了叶子节点，</span><br><span class="hljs-comment">   当到了叶子节点时，就需要将栈顶弹出，存放到结果集合中，然后改变指针的指向为右边    </span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; res=<span class="hljs-literal">new</span> ArrayList&lt;&gt;();<br> <span class="hljs-keyword">if</span>(root==<span class="hljs-built_in">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span>=<span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;&gt;();<br><br>    TreeNode cur=root;<br><br>    <span class="hljs-keyword">while</span>(cur!=<span class="hljs-built_in">null</span> || !<span class="hljs-built_in">stack</span>.isEmpty())&#123;<br>        <span class="hljs-keyword">if</span>(cur!=<span class="hljs-built_in">null</span>)&#123;<br>            <span class="hljs-built_in">stack</span>.push(cur);<span class="hljs-comment">//左</span><br>            cur=cur.left;<br><br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cur=<span class="hljs-built_in">stack</span>.pop();<span class="hljs-comment">//要处理的节点</span><br>            res.add(cur.val);<span class="hljs-comment">//中</span><br>            cur=cur.right;<span class="hljs-comment">//右边</span><br><br><br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br><br>   &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/submissions/">145. 二叉树的后序遍历 </a></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; postorderTraversal(TreeNode root) &#123;<br><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       在前序遍历的基础上，修改进入栈的顺序，先左后右，出栈得到中右左，然后再将结果数组反转得到左右中</span><br><span class="hljs-comment">       注意判断数组为空的情况</span><br><span class="hljs-comment">        */</span><br><br>        <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; res=<span class="hljs-literal">new</span> ArrayList&lt;<span class="hljs-built_in">Integer</span>&gt;();<br><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-built_in">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span>=<span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;&gt;();<br>        <span class="hljs-built_in">stack</span>.push(root);<br>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">stack</span>.isEmpty())&#123;<br>           TreeNode node=<span class="hljs-built_in">stack</span>.pop();<span class="hljs-comment">//中</span><br>           res.add(node.val);<br>           <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-built_in">null</span>)&#123;<br>             <span class="hljs-built_in">stack</span>.push(node.left);<span class="hljs-comment">//左</span><br><br>           &#125;<br>           <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-built_in">null</span>)&#123;<br><br>            <span class="hljs-built_in">stack</span>.push(node.right);<span class="hljs-comment">//右</span><br>           &#125;<br>        &#125;<br><br>       Collections.reverse(res);<br><br>        <span class="hljs-keyword">return</span> res;<br><br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="统一写法"><a href="#统一写法" class="headerlink" title="统一写法"></a>统一写法</h3><p><a target="_blank" rel="noopener" href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">代码随想录 (programmercarl.com)</a></p>
<p>有空细看看</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; levelOrder(TreeNode root) &#123;<br><br>       <span class="hljs-comment">/* </span><br><span class="hljs-comment">       思路:</span><br><span class="hljs-comment">       迭代法：使用队列进行处理遍历得到的元素，先将一层中元素放入到队列中，并计算了该层次结点的元素的个数，</span><br><span class="hljs-comment">       然后 开始遍历，先将队列首部的元素弹出放入到提前定好的数组中，然后将该元素结点的左右子节点放入到数组中，依次循环</span><br><span class="hljs-comment">       进而循环完一层后，就将该层的所有元素都放入到一个数组中，而队列中剩余的元素就是下一层的元素，</span><br><span class="hljs-comment">       然后将该数组添加到结果集合中，然后就开始遍历下一层节点，</span><br><span class="hljs-comment">       等到队列为空，就标识遍历结束，然后返回结果集合即可</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">       */</span><br><br>        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; res=<span class="hljs-built_in">new</span> ArrayList&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt;();<br><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        Queue&lt;TreeNode&gt; que=<span class="hljs-built_in">new</span> LinkedList&lt;TreeNode&gt;();<br><br>        que.<span class="hljs-keyword">add</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            List&lt;<span class="hljs-type">Integer</span>&gt; list=<span class="hljs-built_in">new</span> ArrayList&lt;<span class="hljs-type">Integer</span>&gt;();//用于存储一层的元素<br>            <br>            <span class="hljs-type">int</span> len=que.size();//一层的元素个数<br><br>            <span class="hljs-keyword">while</span>(len&gt;<span class="hljs-number">0</span>)&#123;<br>                TreeNode <span class="hljs-keyword">temp</span>=que.poll();//记录下一层的根节点<br>                list.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">temp</span>.val);//将本层的节点放入到一个数组中<br>                //将下一层的结点放入到队列中<br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">temp</span>.left!=<span class="hljs-keyword">null</span>)&#123;<br>                    que.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">temp</span>.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">temp</span>.right!=<span class="hljs-keyword">null</span>)&#123;<br>                    que.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">temp</span>.right);<br>                &#125;<br>                len<span class="hljs-comment">--;</span><br>            &#125;<br><br>            res.<span class="hljs-keyword">add</span>(list);//放入本层结点数组<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res; <br><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/submissions/">107. 二叉树的层序遍历 II </a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">思路：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在层次遍历的基础上，进行反转</span><br><span class="hljs-comment">层次遍历的实现：使用队列处理从树中得到的元素，先将根节点放入队列中，只有队列不为空，就表示层次遍历还没有结束，</span><br><span class="hljs-comment">定义一个数组用于存储同一层的元素，然后计算出当前对列中的节点的个数，然后再进行循环，不断将首部的元素去除并且将</span><br><span class="hljs-comment">该元素的字节点放入到队尾中，然后将该该节点放入到之前定义的数组中，等到该队列中的父类节点循环结束后，所有父类的字</span><br><span class="hljs-comment">节点也都加入到了队列中，然后依次循环，并且每一次循环结束后，都将该数组添加到结果集合中，最后返回结果集合即可</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>



<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; levelOrderBottom(TreeNode root) &#123;<br><br><br><br>   List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; res=<span class="hljs-built_in">new</span> ArrayList&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt;();<br>   <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br>   Queue&lt;TreeNode&gt; que=<span class="hljs-built_in">new</span> LinkedList&lt;&gt;();<br>   que.<span class="hljs-keyword">add</span>(root);<br>   <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>       <span class="hljs-type">int</span> len=que.size();<br>       List&lt;<span class="hljs-type">Integer</span>&gt; list=<span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br><br><br>       <span class="hljs-keyword">while</span>(len&gt;<span class="hljs-number">0</span>)&#123;<br>           TreeNode node= que.poll();<br>           list.<span class="hljs-keyword">add</span>(node.val);<br>           <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-keyword">null</span>)&#123;<br>               que.<span class="hljs-keyword">add</span>(node.left);<br>           &#125;<br>           <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-keyword">null</span>)&#123;<br>               que.<span class="hljs-keyword">add</span>(node.right);<br>           &#125;<br>           len<span class="hljs-comment">--;</span><br><br>       &#125;<br>       res.<span class="hljs-keyword">add</span>(list);<br><br><br>   &#125;<br><br>   Collections.reverse(res);<br><br>   <span class="hljs-keyword">return</span> res;<br><br><br><br><br></code></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/submissions/">199. 二叉树的右视图 - 力扣（LeetCode）</a></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> List&lt;<span class="hljs-type">Integer</span>&gt; rightSideView(TreeNode root) &#123;<br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">     在二叉树层次遍历的基础上，修改进入结果 集合的对象，使得每一层只有最后一个元素才能进入结果。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     层次遍历：定义一个队列，用于处理遍历得到的二叉树结点，先将父结点放入到结果集合中，在不断去除队列头部的结点值，放入到</span><br><span class="hljs-comment">     结果集中，然后把该结点的左右子结点放入到队列的尾部，每一次遍历完一层就计算长度，这个长度就是下一次遍历的循环次数。</span><br><span class="hljs-comment">     等到队列 为空时，就可以把结果集合返回了</span><br><span class="hljs-comment">     </span><br><span class="hljs-comment">      */</span><br><br>       List&lt;<span class="hljs-type">Integer</span>&gt; res=<span class="hljs-built_in">new</span> ArrayList&lt;<span class="hljs-type">Integer</span>&gt;();<br>       <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> res;<br>       &#125;<br>       Queue&lt;TreeNode&gt; que=<span class="hljs-built_in">new</span> LinkedList&lt;&gt;();<br>       que.<span class="hljs-keyword">add</span>(root);<br>       <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>           <span class="hljs-type">int</span> len=que.size();<br><br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>               TreeNode node=que.poll();<br>               <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-keyword">null</span>)&#123;<br>                   que.<span class="hljs-keyword">add</span>(node.left);<br>               &#125;<br>                <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-keyword">null</span>)&#123;<br>                   que.<span class="hljs-keyword">add</span>(node.right);<br>               &#125;<br><br>               <span class="hljs-keyword">if</span>(i==len<span class="hljs-number">-1</span>)&#123;<br>                     res.<span class="hljs-keyword">add</span>(node.val);<br><br>               &#125;<br>           &#125;<br>       <br><br>       &#125;<br>     <span class="hljs-keyword">return</span> res;<br><br></code></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/submissions/">226. 翻转二叉树 - 力扣（LeetCode）</a>  </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-function"><span class="hljs-title">invertTree</span>(<span class="hljs-params">TreeNode root</span>)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        思路：使用递归</span><br><span class="hljs-comment">        三要素：返回值类型和传入参数：结点</span><br><span class="hljs-comment">                循环的终止条件：结点为空就退出</span><br><span class="hljs-comment">                单次循环逻辑：交换根结点左右结点，然后递归左右接点</span><br><span class="hljs-comment">         */</span><br><br>         duigui(root);<br>         <span class="hljs-keyword">return</span> root;<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">duigui</span>(<span class="hljs-params">TreeNode node</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        TreeNode temp;<br>        <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>||node.right!=<span class="hljs-literal">null</span>)&#123;<br>            temp=node.left;<span class="hljs-comment">//中</span><br>            node.left=node.right;<br>            node.right=temp;<br><br>            duigui(node.left);<span class="hljs-comment">//左</span><br>            duigui(node.right);<span class="hljs-comment">//右</span><br>        &#125;<br>       <br><br>    &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历 - 力扣（LeetCode）</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorder</span>(<span class="hljs-params">Node root</span>)</span> &#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        思路：</span><br><span class="hljs-comment">        递归：</span><br><span class="hljs-comment">        传入参数和返回值类型:结点和结果集</span><br><span class="hljs-comment">        终止条件：结点为空</span><br><span class="hljs-comment">        单次循环逻辑：取出结点的子集，不断进行递归</span><br><span class="hljs-comment">        */</span><br><br>        List&lt;Integer&gt; res=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        res.<span class="hljs-keyword">add</span>(root.val);<span class="hljs-comment">//最先添加头结点</span><br>        duigui(root,res);<br>        <span class="hljs-keyword">return</span> res;<br><br>       <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">duigui</span>(<span class="hljs-params">Node node,List&lt;Integer&gt; res</span>)</span>&#123;<br><br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        List&lt;Node&gt; children=node.children;<br>        <span class="hljs-keyword">for</span>(Node child:children)&#123;<br>            res.<span class="hljs-keyword">add</span>(child.val);<br>            duigui(child,res);<br><br>        &#125;<br><br><br>    &#125;<br></code></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-postorder-traversal/">590. N 叉树的后序遍历 - 力扣（LeetCode）</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">postorder</span>(<span class="hljs-params">Node root</span>)</span> &#123;<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       思路：递归</span><br><span class="hljs-comment">       返回值类型和传入参数：无返回，传入参数一个结点，一个结果集</span><br><span class="hljs-comment">       终止条件，结点为空</span><br><span class="hljs-comment">       单次逻辑：先遍历子节点，后添加中间元素</span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">        */</span><br><br>         List&lt;Integer&gt; res=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>         <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>             <span class="hljs-keyword">return</span> res;<br>         &#125;<br>         dg(root,res);<br>         res.<span class="hljs-keyword">add</span>(root.val);<span class="hljs-comment">//最后添加头结点</span><br>         <span class="hljs-keyword">return</span> res;<br><br><br>       <br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dg</span>(<span class="hljs-params">Node node,List&lt;Integer&gt; res</span>)</span>&#123;<br>       <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> ;<br>       &#125;<br>       <br>       List&lt;Node&gt; children=node.children;<br>       <span class="hljs-keyword">for</span>(Node child:children)&#123;<br>           dg(child,res);<br>           res.<span class="hljs-keyword">add</span>(child.val);<br><br><br>       &#125;<br>       <br>   &#125;<br><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/submissions/">144. 二叉树的前序遍历 - 力扣（LeetCode）</a></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; preorderTraversal(TreeNode root) &#123;<br><br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">     迭代法：利用栈处理的遍历得到的元素，先中间结点入栈，然后右结点入栈，然后左节点入栈，等到出栈的时候，就成了中左右的顺序。</span><br><span class="hljs-comment">     </span><br><span class="hljs-comment">      */</span><br>  <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; res=<span class="hljs-literal">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-keyword">if</span>(root==<span class="hljs-built_in">null</span>)&#123;<br>      <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span>=<span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;&gt;();<br>  <span class="hljs-built_in">stack</span>.push(root);<br>  <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">stack</span>.isEmpty())&#123;<br>      TreeNode node=<span class="hljs-built_in">stack</span>.pop();<br>      res.add(node.val);<span class="hljs-comment">//中</span><br><br>      <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-built_in">null</span>)&#123;<br>          <span class="hljs-built_in">stack</span>.push(node.right);<span class="hljs-comment">//右</span><br><br>      &#125;<br>      <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-built_in">null</span>)&#123;<br>          <span class="hljs-built_in">stack</span>.push(node.left);<span class="hljs-comment">//左</span><br>      &#125;<br><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/submissions/">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; inorderTraversal(TreeNode root) &#123;<br><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       迭代法：</span><br><span class="hljs-comment">       在前序遍历的基础上进行改进，这里要增加一个指针，用于判断是否到达叶子节点，不是叶子节点，就将他直接放入栈中，是叶子点，就在弹出栈顶，并 放入结果集合中，并将指针指向右边。</span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">        */</span><br><br>        <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; res=<span class="hljs-literal">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-built_in">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span>=<span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;&gt;();<br>        TreeNode node=root;<br><br>        <span class="hljs-keyword">while</span>(node!=<span class="hljs-built_in">null</span>||!<span class="hljs-built_in">stack</span>.isEmpty())&#123;<br>            <span class="hljs-keyword">if</span>(node!=<span class="hljs-built_in">null</span>)&#123;<br>                <span class="hljs-built_in">stack</span>.push(node);<br>                node=node.left;<br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                node=<span class="hljs-built_in">stack</span>.pop();<br>                res.add(node.val);<br>                node=node.right;<br><br><br>            &#125;<br><br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> res;<br><br></code></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/submissions/">637. 二叉树的层平均值 - 力扣（LeetCode）</a></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> List&lt;<span class="hljs-type">Double</span>&gt; averageOfLevels(TreeNode root) &#123;<br>      <span class="hljs-comment">/* </span><br><span class="hljs-comment">      average</span><br><span class="hljs-comment">      层次遍历：</span><br><span class="hljs-comment">      使用一个队列处理每一层的值，将父节点放入数组中后，计算栈的长度，然后循环从队列的队头部弹出值，将该节点的左右字子节点</span><br><span class="hljs-comment">      放入队列尾部，并将该头部放入一个数组中，等到遍历一层结束，数组中都是一层节点的值，队列中都是下一层的节点，最后将数组放入结果集中，左后返回结果集合即可</span><br><span class="hljs-comment">      </span><br><span class="hljs-comment">      </span><br><span class="hljs-comment">      */</span><br><br>      List&lt;<span class="hljs-type">Double</span>&gt; res=<span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br><br>      <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>          <span class="hljs-keyword">return</span> res;<br>      &#125;<br><br>      Queue&lt;TreeNode&gt; que=<span class="hljs-built_in">new</span> LinkedList&lt;&gt;();<br>      que.<span class="hljs-keyword">add</span>(root);<br>      <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br><br>          List&lt;<span class="hljs-type">Integer</span>&gt; list=<span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>          <span class="hljs-type">int</span> len=que.size();<br><br><br>          <span class="hljs-keyword">while</span>(len&gt;<span class="hljs-number">0</span>)&#123;<br>              TreeNode node=que.poll();<br>              list.<span class="hljs-keyword">add</span>(node.val);<br>              <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-keyword">null</span>)&#123;<br>                  que.<span class="hljs-keyword">add</span>(node.left);<br>              &#125;<br>              <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-keyword">null</span>)&#123;<br>                  que.<span class="hljs-keyword">add</span>(node.right);<br>              &#125;<br>              len<span class="hljs-comment">--;</span><br>          &#125;<br><br>          <span class="hljs-type">Double</span> avg=average(list);<br><br>          res.<span class="hljs-keyword">add</span>(avg);<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> res;<br><br><br><br><br>  &#125;<br><br><br>  <span class="hljs-built_in">public</span> <span class="hljs-type">Double</span> average(List&lt;<span class="hljs-type">Integer</span>&gt; list)&#123;<br><br>      <span class="hljs-type">Double</span> avg=<span class="hljs-number">0.0</span>;<br>      <span class="hljs-type">Double</span> sum=<span class="hljs-number">0.0</span>;<br>      <span class="hljs-type">int</span> len=list.size();<br><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:list)&#123;<br>          sum+=i;<br>      &#125;<br><br>      avg=sum/len;<br><br>      <span class="hljs-keyword">return</span> avg;<br><br>  &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/submissions/">101. 对称二叉树 </a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">    递归法：</span><br><span class="hljs-comment">    返回值类型和传入参数：布尔型，左右子树的节点</span><br><span class="hljs-comment">    循环的终止条件：左右节点不对称(左节点为空，右节点不为空。右节点不为空，左节点为空。左右节点不为空</span><br><span class="hljs-comment">    但不相等)</span><br><span class="hljs-comment">    左右节点都为空</span><br><span class="hljs-comment">    单次循环逻辑：判断左右子树是都对称,左树的遍历顺序为左右中，右子树的遍历顺序是右左中（即内测和内测比</span><br><span class="hljs-comment">    外侧和外侧比）</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>



<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><br> <br>      <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>      &#125;<br><br>     <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">duigui</span><span class="hljs-params">(root.left,root.right)</span></span>;<br><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">duigui</span><span class="hljs-params">(TreeNode left,TreeNode right)</span></span>&#123;<br><br>      <span class="hljs-keyword">if</span>(left==<span class="hljs-keyword">null</span>&amp;&amp;right==<span class="hljs-keyword">null</span>)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>      &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(left==<span class="hljs-keyword">null</span>&amp;&amp;right!=<span class="hljs-keyword">null</span>)</span></span>&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>      &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(left!=<span class="hljs-keyword">null</span>&amp;&amp;right==<span class="hljs-keyword">null</span>)</span></span>&#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>      &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(left.val!=right.val)</span></span>&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>      &#125;<br><br>     <span class="hljs-keyword">boolean</span> outFlag=duigui(left.left,right.right);<span class="hljs-comment">//树的外侧</span><br>     <span class="hljs-keyword">boolean</span> inFlag=duigui(left.right,right.left);<span class="hljs-comment">//树的内测</span><br><br>     <span class="hljs-keyword">boolean</span> flag=outFlag&amp;inFlag;<br><br>     <span class="hljs-keyword">return</span> flag;<br><br>      <br>  &#125;<br></code></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/submissions/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">    <span class="hljs-comment">/* </span><br><span class="hljs-comment">    思路一：层次遍历的结果集合的长度就是深度。</span><br><span class="hljs-comment">    思路二：递归计算各个叶结点，然后将长度存放在结果集合中</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    递归三要素：</span><br><span class="hljs-comment">            传入参数和返回值类型</span><br><span class="hljs-comment">            递归的终止条件</span><br><span class="hljs-comment">            单次循环的逻辑</span><br><span class="hljs-comment">*/</span><br><br>List&lt;<span class="hljs-type">Integer</span>&gt; list=<span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>getlen(root,<span class="hljs-number">0</span>,list);<br><br><span class="hljs-keyword">return</span> Collections.max (list);<br><br>&#125;<br><br><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> getlen(TreeNode node,<span class="hljs-type">int</span> len,List&lt;<span class="hljs-type">Integer</span>&gt; list)&#123;<br><br>    <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>)&#123;<br><br>        list.<span class="hljs-keyword">add</span>(len);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    len++;<br>    getlen(node.left,len,list);<br><br>    getlen(node.right,len,list);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解法二</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       递归法：是由后序遍历的方式，</span><br><span class="hljs-comment">       递归计算出左右子树的深度，返回深度大的加上一，作为返回值</span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">        */</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">getlen</span><span class="hljs-params">(root)</span></span>;<br><br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getlen</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>       &#125;<br><br>       <span class="hljs-keyword">int</span> leftlen=getlen(node.left);<span class="hljs-comment">//左</span><br>       <span class="hljs-keyword">int</span> rightlen=getlen(node.right);<span class="hljs-comment">//右</span><br><br>       <span class="hljs-keyword">int</span> maxlen=<span class="hljs-number">1</span>+Math.max(leftlen,rightlen);<span class="hljs-comment">//中</span><br><br>       <span class="hljs-keyword">return</span> maxlen;<br><br>   &#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(x1,x2)<span class="hljs-comment">//返回两个数中的最大值</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections</span>.</span></span>max<span class="hljs-literal">()</span><span class="hljs-comment">//返回数组中的最大数值</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/submissions/">559. N 叉树的最大深度 - 力扣（LeetCode）</a></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        递归法：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        传入参数和返回值类型：传入结点和和返回整数</span><br><span class="hljs-comment">        循环的终止条件：结点为空</span><br><span class="hljs-comment">        单次循环逻辑：取出子节点的最大值 </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getlen</span>(root);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getlen</span><span class="hljs-params">(Node node)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(node==null)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> max=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(Node child:node.children)&#123;<br>         <br>            max=Math.<span class="hljs-built_in">max</span>(max,<span class="hljs-built_in">getlen</span>(child));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> max+<span class="hljs-number">1</span>;<br><br><br>    &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/submissions/">111. 二叉树的最小深度 - 力扣（LeetCode）</a></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">递归法：</span><br><span class="hljs-comment">这里采用的遍历顺序是，左右中</span><br><span class="hljs-comment">与求最大长度不同，最小深度需要判断左右子树为空的情况，</span><br><span class="hljs-comment">否则就会误以为没有左子树的结点就是叶节点，当一个结点只有右子树，</span><br><span class="hljs-comment">那么长度就等于右子树的深度加上1，如果只有左子树，就左子树的长度加1，</span><br><span class="hljs-comment">然后就是左右子树都不为空的情况，便可以开始递归</span><br><span class="hljs-comment">寻找左右子树中的最小长度，然后加上1，。</span><br><span class="hljs-comment">*/</span><br><br>       <br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">getlen</span><span class="hljs-params">(root)</span></span>;<br><br><br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getlen</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>        <span class="hljs-comment">//终止条件</span><br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> left=getlen(node.left);<br>        <span class="hljs-keyword">int</span> right=getlen(node.right);<br><br>        <span class="hljs-comment">//左子树为空的情况</span><br>        <span class="hljs-keyword">if</span>(node.left==<span class="hljs-keyword">null</span>&amp;&amp;node.right!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> right+<span class="hljs-number">1</span>;<br><br>        &#125;<br>        <span class="hljs-comment">//右子树为空的情况</span><br>        <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-keyword">null</span>&amp;&amp;node.right==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> left+<span class="hljs-number">1</span>;<br><br>        &#125;<br><br>      <br><br>        <span class="hljs-comment">//取深度小的</span><br>          <span class="hljs-keyword">int</span> min=<span class="hljs-number">1</span>+Math.min(left,right);<br>        <br>        <span class="hljs-keyword">return</span> min;<br>        <br>    &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/submissions/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       基于求最大树的最大深度进行修改，递归的思路是，</span><br><span class="hljs-comment">       返回求出左右子树的结点树，递归的结束条件是，结点为空，就返回0，</span><br><span class="hljs-comment">       然后将左右子树相加，然加上一个根节点的数目进行返回即可。</span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">        */</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">getcount</span><span class="hljs-params">(root)</span></span>;<br><br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getcount</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br><br>       <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">int</span> left=getcount(node.left);<br>       <span class="hljs-keyword">int</span> right=getcount(node.right);<br><br>       <span class="hljs-keyword">int</span> count= left+right+<span class="hljs-number">1</span>;<br><br>       <span class="hljs-keyword">return</span> count;<br><br>   &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/submissions/">110. 平衡二叉树</a></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       在求二叉树的最大深度上进行改进，分别计算 左右子树的最大深度,然后计算左右子树的深度的绝对值差</span><br><span class="hljs-comment">       递归三要素：</span><br><span class="hljs-comment">       传入参数：结点，返回值类型：整形</span><br><span class="hljs-comment">       结束条件：结点为空</span><br><span class="hljs-comment">       单次 循环逻辑：不断递归左右子树，直到遍历到根结点</span><br><span class="hljs-comment">       注意：这里要判断的是二叉树的每个结点的左右子树的高度差的绝对值是否超过1，如果在递归的过程中，就已经存在左右子树</span><br><span class="hljs-comment">       的高度绝对值超过1，就直接返回-1，代表失败，就不用继续递归了</span><br><span class="hljs-comment">        */</span><br>      <span class="hljs-keyword">boolean</span> ans= <span class="hljs-built_in">getlen</span>(root)==<span class="hljs-number">-1</span>?<span class="hljs-literal">false</span>:<span class="hljs-literal">true</span>;<br><br>      <span class="hljs-keyword">return</span> ans;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getlen</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br><br>       <span class="hljs-keyword">if</span>(node==null)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">int</span> left=<span class="hljs-built_in">getlen</span>(node.left);<br>       <span class="hljs-keyword">if</span>(left==<span class="hljs-number">-1</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">int</span> right=<span class="hljs-built_in">getlen</span>(node.right);<br>        <span class="hljs-keyword">if</span>(right==<span class="hljs-number">-1</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>       &#125;<br><br>      <span class="hljs-keyword">int</span> res= Math.<span class="hljs-built_in">abs</span>(left-right)&gt;<span class="hljs-number">1</span>?<span class="hljs-number">-1</span>:Math.<span class="hljs-built_in">max</span>(left,right)+<span class="hljs-number">1</span>;<br>     <br><br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/submissions/">257. 二叉树的所有路径</a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  思路：</span><br><span class="hljs-comment">  递归与回溯的结合，</span><br><span class="hljs-comment">  递归三三要素：</span><br><span class="hljs-comment">  传入参数 ：结点值，路径集合，最终结果集合</span><br><span class="hljs-comment">  循环的终止条件：左右结点同时时为空，要进行终止逻辑处理，即把结点处理成特定字符串，然后添加</span><br><span class="hljs-comment">  到结果集合中</span><br><span class="hljs-comment">  单次循逻辑：</span><br><span class="hljs-comment">  先判断左右子节点是否为空，然后进行递归，回溯</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   */</span><br></code></pre></td></tr></table></figure>



<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;<br><br>  <br>         List&lt;String&gt; res=<span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>         <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>             <span class="hljs-keyword">return</span> res;<br>         &#125;<br>        List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>=<span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>        <br>         getPath(root,<span class="hljs-type">path</span>,res);<br><br>         <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> getPath(TreeNode node,List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>,List&lt;String&gt; res)&#123;<br>        <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(node.val);<br><br>        <span class="hljs-keyword">if</span>(node.left==<span class="hljs-keyword">null</span>&amp;&amp;node.right==<span class="hljs-keyword">null</span>)&#123;<br>            String spath=&quot;&quot;;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-type">path</span>.size()<span class="hljs-number">-1</span>;i++)&#123;<br>                spath=spath+<span class="hljs-type">path</span>.<span class="hljs-keyword">get</span>(i);<br>                spath=spath+&quot;-&gt;&quot;;<br>            &#125;<br>            //最后一个结点的添加<br>             spath=spath+<span class="hljs-type">path</span>.<span class="hljs-keyword">get</span>(<span class="hljs-type">path</span>.size()<span class="hljs-number">-1</span>);<br><br>             res.<span class="hljs-keyword">add</span>(spath);<br><br><br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-keyword">null</span>)&#123;<br>            getPath(node.left,<span class="hljs-type">path</span>,res);//递归<br>            <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size()<span class="hljs-number">-1</span>);//回溯<br><br>        &#125;<br>        <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-keyword">null</span>)&#123;<br>            getPath(node.right,<span class="hljs-type">path</span>,res);<br>            <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size()<span class="hljs-number">-1</span>);<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/submissions/">100. 相同的树 </a></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> </span>&#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        对称的数基础上进行改进，对称树是内测与内测进行比较，外侧与内侧进行比较，</span><br><span class="hljs-comment">        即左子树的左子树和右子树的右子树比较,即左子树的右子树和右子树的左子树比较。</span><br><span class="hljs-comment">        这里是比较两个相同的树，就是比较对应位置的树是否相等，即左子树的左子树和右子树的左子树进行比较，</span><br><span class="hljs-comment">        左子树的右子树和右子树进行比较。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        递归三要素:</span><br><span class="hljs-comment">        返回值类型和传入参数,传入的两个节点，返回值布尔类型</span><br><span class="hljs-comment">        单次循环逻辑：传入左右子节点</span><br><span class="hljs-comment">        终止条件：对应位置的数不相同</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">         */</span><br><br>         <br><br>         <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">isame</span><span class="hljs-params">(p,q)</span></span>;<br><br><br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isame</span><span class="hljs-params">(TreeNode left,TreeNode right)</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-keyword">null</span>&amp;&amp;right==<span class="hljs-keyword">null</span>)&#123;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(left==<span class="hljs-keyword">null</span>&amp;&amp;right!=<span class="hljs-keyword">null</span>)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(left!=<span class="hljs-keyword">null</span>&amp;&amp;right==<span class="hljs-keyword">null</span>)</span></span>&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span><span class="hljs-params">(left.val!=right.val)</span></span>&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">boolean</span> leftflag=isame(left.left,right.left);<br>        <span class="hljs-keyword">boolean</span> rightflag=isame(left.right,right.right);<br><br>        <span class="hljs-keyword">boolean</span> flag=leftflag&amp;rightflag;<br><br>        <span class="hljs-keyword">return</span> flag;<br><br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/submissions/">404. 左叶子之和 </a></p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> sumOfLeftLeaves(TreeNode root) &#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这里重要是的左叶子的判断，左叶子的判断是通过其父结点的左结点不为空而左结点的左右子节点都为空，</span><br><span class="hljs-comment">        然后就把这个结点的值复制给叶子结点。</span><br><span class="hljs-comment">        终止条件:结点为空</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">         */</span><br><br>         <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>         &#125;<br><br>         <span class="hljs-built_in">int</span> leftvalue=sumOfLeftLeaves(root.left);<br><br>         <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>&amp;&amp;root.left.left==<span class="hljs-literal">null</span>&amp;&amp;root.left.right==<span class="hljs-literal">null</span>)&#123;<br>                leftvalue=root.left.val;<br><br>         &#125;<br>         <span class="hljs-built_in">int</span> rightValue=sumOfLeftLeaves(root.right);<br><br>         <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span>=leftvalue+rightValue;<br><br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">sum</span>;<br><br>    &#125;<br></code></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/submissions/">513. 找树左下角的值</a></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> findBottomLeftValue(TreeNode root) &#123;<br><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       使用层次遍历，使用一个栈进行处理元素，将节点放入栈中，计算出栈的长度，然后遍历该栈，</span><br><span class="hljs-comment">       将该栈中的节点的字</span><br><span class="hljs-comment">       节点加入到栈中，然后弹出该节点。</span><br><span class="hljs-comment">       每次遍历时，用一个都记录一下每层的最左边的节点，等到最后一层的时候，</span><br><span class="hljs-comment">       该元素也就更新成了最底层的最左边的元素</span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">        */</span><br><br><br>        <span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;<br><br>        Queue&lt;TreeNode&gt; que=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>        que.<span class="hljs-built_in">add</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!que.isEmpty())&#123;<br>            <br><br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span>=que.<span class="hljs-built_in">size</span>();<br><br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">size</span>;i++)&#123;<br><br>                TreeNode head=que.poll();<br><br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)&#123;<br>                    res=head.val;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(head.left!=<span class="hljs-keyword">null</span>)&#123;<br>                    que.<span class="hljs-built_in">add</span>(head.left);<br><br>                &#125;<br>                <span class="hljs-keyword">if</span>(head.right!=<span class="hljs-keyword">null</span>)&#123;<br>                    que.<span class="hljs-built_in">add</span>(head.right);<br><br>                &#125;<br><br>       <br><br>            &#125;<br><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br>   &#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">int</span> maxDeep=Integer.MIN_VALUE;<br>   <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       注意:最左边的值不一定是左叶子节点</span><br><span class="hljs-comment">       定义一个计数器，用于记录达到叶子节点的深度，当深度大于原来的最大深度时，就把新的最大深度赋给它，</span><br><span class="hljs-comment">       还要更新这个值。</span><br><span class="hljs-comment">       递归三要素：传入参数：节点名称，计数器</span><br><span class="hljs-comment">       单次循环逻辑：先后递归左右子节点，递归时计数器就加一，回溯就减一</span><br><span class="hljs-comment">       终止条件：左右字节点都为空</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">        */</span><br><br>        getleft(root,<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> res;<br>       <br><br>   &#125;<br><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getleft</span><span class="hljs-params">(TreeNode node,<span class="hljs-keyword">int</span> deep)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(node.left==<span class="hljs-keyword">null</span>&amp;&amp;node.right==<span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">if</span>(deep&gt;maxDeep)&#123;<br>               maxDeep=deep;<br>               res=node.val;<br>           &#125;<br><br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       <span class="hljs-comment">//左</span><br>       <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-keyword">null</span>)&#123;<br>           deep++;<br>           getleft(node.left,deep);<br>           deep--;<br><br>       &#125;<br><br>       <span class="hljs-comment">//右</span><br>       <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-keyword">null</span>)&#123;<br>           deep++;<br>           getleft(node.right,deep);<br>           deep--;<br><br>       &#125;<br><br>       <span class="hljs-keyword">return</span>;<br><br><br>   &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/submissions/">112. 路径总和</a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/* </span><br><span class="hljs-comment">       递归每一条路径，然后判断该路径的和是否与目标值相等</span><br><span class="hljs-comment">       递归与回溯并存</span><br><span class="hljs-comment">       递归三要素：</span><br><span class="hljs-comment">       终止条件：节点左右孩子都为空，这里需要进行逻辑处理，，判断该路劲的和与目标值是否相等</span><br><span class="hljs-comment">       传入参数：节点和路径集合</span><br><span class="hljs-comment">       返回值：布尔值类型，遇到成功就返回</span><br><span class="hljs-comment">       单次循环逻辑：不断将左右节点进行递归，只要字节点递归的返回结果为真，就返回为真</span><br><span class="hljs-comment">       */</span><br></code></pre></td></tr></table></figure>



<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br><br>       <br>            <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            List&lt;Integer&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">isSum</span><span class="hljs-params">(root,list,targetSum)</span></span>;<br>        <br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSum</span><span class="hljs-params">(TreeNode node,List&lt;Integer&gt; list,<span class="hljs-keyword">int</span> targetSum)</span></span>&#123;<br>        list.add(node.val);<br>        <br>        <span class="hljs-keyword">if</span>(node.left==<span class="hljs-keyword">null</span>&amp;&amp;node.right==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> val:list)&#123;<br>                sum+=val;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(sum==targetSum)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>            &#125;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//递归</span><br>            <span class="hljs-keyword">if</span>(isSum(node.left,list,targetSum))&#123;<br>                <span class="hljs-comment">//遇到为符合的就返回</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            list.remove(list.size()<span class="hljs-number">-1</span>);<span class="hljs-comment">//回溯</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-comment">//递归</span><br>            <span class="hljs-keyword">if</span>(isSum(node.right,list,targetSum))&#123;<br>                 <span class="hljs-comment">//遇到为符合的就返回</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            list.remove(list.size()<span class="hljs-number">-1</span>);<span class="hljs-comment">//回溯</span><br><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/submissions/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public TreeNode build<span class="hljs-constructor">Tree(<span class="hljs-params">int</span>[] <span class="hljs-params">inorder</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">postorder</span>)</span> &#123;<br><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       利用后序数组的最后一个作为突破口，因为这个元素是根节点，然后再利用这个元素去中序数组去进行切分，</span><br><span class="hljs-comment">       然后得到了</span><br><span class="hljs-comment">       左右子树的长度，然后再利用左右子树的长度，去中序数组中，找左右子树，</span><br><span class="hljs-comment">       此时左子树的最后一个结点就是该左子树的根节点</span><br><span class="hljs-comment">       ，右子树也是，利用这个思路就可不断递归</span><br><span class="hljs-comment">       递归的终止条件就是：中序遍历的子树长度为0。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span>(inorder.length==<span class="hljs-number">0</span><span class="hljs-pattern-match"><span class="hljs-operator">||</span>postorder.length<span class="hljs-operator">==</span>0)&#123;</span><br><span class="hljs-pattern-match">            return null;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">       return get<span class="hljs-constructor">Tree(<span class="hljs-params">inorder</span>,<span class="hljs-params">postorder</span>)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">   &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">   public <span class="hljs-constructor">TreeNode</span> get<span class="hljs-constructor">Tree(<span class="hljs-params">int</span>[] <span class="hljs-params">inorder</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">postorder</span>)</span>&#123;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">       <span class="hljs-keyword">if</span>(postorder.length<span class="hljs-operator">==</span>0)&#123;</span><br><span class="hljs-pattern-match">           return null;</span><br><span class="hljs-pattern-match">       &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">       <span class="hljs-operator">/</span><span class="hljs-operator">/</span>1.找后序遍历的最后一个结点</span><br><span class="hljs-pattern-match">       <span class="hljs-built_in">int</span> rootvalue=postorder[postorder.length-1];</span><br><span class="hljs-pattern-match">       <span class="hljs-constructor">TreeNode</span> root=<span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">rootvalue</span>)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">       <span class="hljs-operator">/</span><span class="hljs-operator">/</span>遍历到叶子结点</span><br><span class="hljs-pattern-match">       <span class="hljs-keyword">if</span>(postorder.length<span class="hljs-operator">==</span>1)&#123;</span><br><span class="hljs-pattern-match">           return root;</span><br><span class="hljs-pattern-match">       &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">       <span class="hljs-operator">/</span><span class="hljs-operator">/</span>2.利用后续遍历的最后一个结点对中序遍历进行切分，找到切割点</span><br><span class="hljs-pattern-match">       <span class="hljs-built_in">int</span> splitindex;</span><br><span class="hljs-pattern-match">       <span class="hljs-keyword">for</span>(splitindex=0;splitindex&lt;inorder.length;splitindex<span class="hljs-operator">++</span>)&#123;</span><br><span class="hljs-pattern-match">           <span class="hljs-keyword">if</span>(inorder[splitindex]<span class="hljs-operator">==</span>rootvalue)&#123;</span><br><span class="hljs-pattern-match">               break;</span><br><span class="hljs-pattern-match">           &#125;</span><br><span class="hljs-pattern-match">       &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">       <span class="hljs-operator">/</span><span class="hljs-operator">/</span>3.求出切分后的中序数组</span><br><span class="hljs-pattern-match">       <span class="hljs-built_in">int</span>[] left<span class="hljs-constructor">Inorder</span>= <span class="hljs-constructor">Arrays</span>.copy<span class="hljs-constructor">OfRange(<span class="hljs-params">inorder</span>,0,0+<span class="hljs-params">splitindex</span>)</span>;</span><br><span class="hljs-pattern-match">       <span class="hljs-built_in">int</span>[] right<span class="hljs-constructor">Inorder</span>=<span class="hljs-constructor">Arrays</span>.copy<span class="hljs-constructor">OfRange(<span class="hljs-params">inorder</span>,<span class="hljs-params">splitindex</span>+1,<span class="hljs-params">inorder</span>.<span class="hljs-params">length</span>)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">       <span class="hljs-operator">/</span><span class="hljs-operator">/</span>4.删除后续遍历的后续数组</span><br><span class="hljs-pattern-match">       </span><br><span class="hljs-pattern-match">       postorder=<span class="hljs-constructor">Arrays</span>.copy<span class="hljs-constructor">OfRange(<span class="hljs-params">postorder</span>,0,<span class="hljs-params">postorder</span>.<span class="hljs-params">length</span>-1)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">       <span class="hljs-operator">/</span><span class="hljs-operator">/</span>5.切割后续数组</span><br><span class="hljs-pattern-match">       <span class="hljs-built_in">int</span>[] left<span class="hljs-constructor">Postorder</span>= <span class="hljs-constructor">Arrays</span>.copy<span class="hljs-constructor">OfRange(<span class="hljs-params">postorder</span>,0,0+<span class="hljs-params">leftInorder</span>.<span class="hljs-params">length</span>)</span>;</span><br><span class="hljs-pattern-match">       <span class="hljs-built_in">int</span>[] right<span class="hljs-constructor">Postorder</span>=<span class="hljs-constructor">Arrays</span>.copy<span class="hljs-constructor">OfRange(<span class="hljs-params">postorder</span>,0+<span class="hljs-params">leftInorder</span>.<span class="hljs-params">length</span>,<span class="hljs-params">postorder</span>.<span class="hljs-params">length</span>)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">       <span class="hljs-operator">/</span><span class="hljs-operator">/</span>6.递归左右子树</span><br><span class="hljs-pattern-match">       root.left=get<span class="hljs-constructor">Tree(<span class="hljs-params">leftInorder</span>,<span class="hljs-params">leftPostorder</span>)</span>;</span><br><span class="hljs-pattern-match">       root.right=get<span class="hljs-constructor">Tree(<span class="hljs-params">rightInorder</span>,<span class="hljs-params">rightPostorder</span>)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">       return root;</span><br><span class="hljs-pattern-match"></span><br></code></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">data</span>,2,7)</span>;截取数组<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/submissions/">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public TreeNode build<span class="hljs-constructor">Tree(<span class="hljs-params">int</span>[] <span class="hljs-params">preorder</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">inorder</span>)</span> &#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        思路：利用先序遍历的特点，找到先序遍历数组中的头结点，一定就是根节点，然后在利用根节点</span><br><span class="hljs-comment">        去中序数组中找分割点，找到分割点后，就取出中序遍历的左右子树，然后再去掉先序遍历的头结点</span><br><span class="hljs-comment">        ，然后利用中序遍历取出的左右子数组的长度，去先序遍历中取出，左右子数组。</span><br><span class="hljs-comment">        然后就是递归，递归得到的左右子数组，最后返回根节点即可</span><br><span class="hljs-comment">        递归的终止条件就是：先序子数组为空</span><br><span class="hljs-comment">        遇到先序数组长度为1的就返回根节点</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">         */</span><br><br>         <span class="hljs-keyword">if</span>(preorder.length==<span class="hljs-number">0</span><span class="hljs-pattern-match"><span class="hljs-operator">||</span>inorder.length<span class="hljs-operator">==</span>0)&#123;</span><br><span class="hljs-pattern-match">             return null;</span><br><span class="hljs-pattern-match">         &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">         return get<span class="hljs-constructor">Tree(<span class="hljs-params">preorder</span>,<span class="hljs-params">inorder</span>)</span>;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">    public <span class="hljs-constructor">TreeNode</span> get<span class="hljs-constructor">Tree(<span class="hljs-params">int</span>[] <span class="hljs-params">preorder</span>, <span class="hljs-params">int</span>[] <span class="hljs-params">inorder</span> )</span>&#123;</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span>(preorder.length<span class="hljs-operator">==</span>0)&#123;</span><br><span class="hljs-pattern-match">            return null;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>1.找先序遍历的第一个结点</span><br><span class="hljs-pattern-match">        <span class="hljs-built_in">int</span> head=preorder[0];</span><br><span class="hljs-pattern-match">        <span class="hljs-constructor">TreeNode</span> root=<span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">head</span>)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span>(preorder.length<span class="hljs-operator">==</span>1)&#123;</span><br><span class="hljs-pattern-match">            return root;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        <span class="hljs-built_in">int</span> splite<span class="hljs-constructor">Index</span>=0;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>2.找分割点</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">for</span>(;splite<span class="hljs-constructor">Index</span>&lt;inorder.length;splite<span class="hljs-constructor">Index</span><span class="hljs-operator">++</span>)&#123;</span><br><span class="hljs-pattern-match">            <span class="hljs-keyword">if</span>(inorder[splite<span class="hljs-constructor">Index</span>]<span class="hljs-operator">==</span>head)&#123;</span><br><span class="hljs-pattern-match">                break;</span><br><span class="hljs-pattern-match">            &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        </span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>3.切分中序数组</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        <span class="hljs-built_in">int</span>[] left<span class="hljs-constructor">Inoder</span>=<span class="hljs-constructor">Arrays</span>.copy<span class="hljs-constructor">OfRange(<span class="hljs-params">inorder</span>,0,0+<span class="hljs-params">spliteIndex</span>)</span>;</span><br><span class="hljs-pattern-match">        <span class="hljs-built_in">int</span>[] right<span class="hljs-constructor">Inoder</span>=<span class="hljs-constructor">Arrays</span>.copy<span class="hljs-constructor">OfRange(<span class="hljs-params">inorder</span>,0+<span class="hljs-params">spliteIndex</span>+1,<span class="hljs-params">inorder</span>.<span class="hljs-params">length</span>)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>4.取出先序数组的第一个结点</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        preorder=<span class="hljs-constructor">Arrays</span>.copy<span class="hljs-constructor">OfRange(<span class="hljs-params">preorder</span>,1,<span class="hljs-params">preorder</span>.<span class="hljs-params">length</span>)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>5.切分先序数组</span><br><span class="hljs-pattern-match">        <span class="hljs-built_in">int</span>[] left<span class="hljs-constructor">Preorder</span>=<span class="hljs-constructor">Arrays</span>.copy<span class="hljs-constructor">OfRange(<span class="hljs-params">preorder</span>,0,0+<span class="hljs-params">leftInoder</span>.<span class="hljs-params">length</span>)</span>;</span><br><span class="hljs-pattern-match">        <span class="hljs-built_in">int</span>[] right<span class="hljs-constructor">Preorder</span>=<span class="hljs-constructor">Arrays</span>.copy<span class="hljs-constructor">OfRange(<span class="hljs-params">preorder</span>,0+<span class="hljs-params">leftInoder</span>.<span class="hljs-params">length</span>,<span class="hljs-params">preorder</span>.<span class="hljs-params">length</span>)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>6.递归</span><br><span class="hljs-pattern-match">        root.left=get<span class="hljs-constructor">Tree(<span class="hljs-params">leftPreorder</span>,<span class="hljs-params">leftInoder</span>)</span>;</span><br><span class="hljs-pattern-match">        root.right=get<span class="hljs-constructor">Tree(<span class="hljs-params">rightPreorder</span>,<span class="hljs-params">rightInoder</span>)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        return root;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"></span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/submissions/">654. 最大二叉树 </a></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">      思路：</span><br><span class="hljs-comment">      首先在数组中找到最大值，然后将最大值作为分割点，切分左右子树，递归返回</span><br><span class="hljs-comment">      递归三要素：</span><br><span class="hljs-comment">      递归的终止条件：结点为空</span><br><span class="hljs-comment">      单次逻辑：找最大值作为根结点，切分数组，然后递归 </span><br><span class="hljs-comment">      返回值类型，结点，传入参数（结点）</span><br><span class="hljs-comment">      </span><br><span class="hljs-comment">       */</span><br><br></code></pre></td></tr></table></figure>



<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public TreeNode construct<span class="hljs-constructor">MaximumBinaryTree(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;<br><br>     <br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span>)&#123;<br>            return null;<br><br>        &#125;<br><br>        return get<span class="hljs-constructor">Maxtree(<span class="hljs-params">nums</span>)</span>;<br>        <br><br>   &#125;<br><br>   public TreeNode get<span class="hljs-constructor">Maxtree(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span>&#123;<br>       <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span>)&#123;<br>            return null;<br><br>        &#125;<br>        <br><br><br><br>        <span class="hljs-built_in">int</span> max=Integer.MIN_VALUE;<br>        <span class="hljs-built_in">int</span> spliteIndex=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//找最大值</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>&gt;max)&#123;<br>                max=nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>                spliteIndex=i;<br><br>            &#125;<br><br>        &#125;<br>        TreeNode root=<span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">max</span>)</span>;<br><br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">1</span>)&#123;<br>            return root;<br><br>        &#125;<br><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> leftNums=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">nums</span>,0,0+<span class="hljs-params">spliteIndex</span>)</span>;<br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> rightNums=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">nums</span>,0+<span class="hljs-params">spliteIndex</span>+1,<span class="hljs-params">nums</span>.<span class="hljs-params">length</span>)</span>;<br><br>       root.left=get<span class="hljs-constructor">Maxtree(<span class="hljs-params">leftNums</span>)</span>;<br>       root.right=get<span class="hljs-constructor">Maxtree(<span class="hljs-params">rightNums</span>)</span>;<br><br><br>       return root;<br><br><br><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/183/learning/">完全二叉树的权值 - 蓝桥云课 (lanqiao.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/submissions/">617. 合并二叉树 - 力扣（LeetCode）</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       思路：递归</span><br><span class="hljs-comment">       传入参数和返回值类型：返回值类型：结点，传入左右子树的结点</span><br><span class="hljs-comment">       终止条件：两个结点都为空，</span><br><span class="hljs-comment">       单次循环逻辑：先判断两个子树是否为为空，其中一个子树为空，就返回另外一个子树解答</span><br><span class="hljs-comment">       当两个子树都不为空时，就加上这两个结点的值，然后分别递归两颗树的左子结点和右子结点，</span><br><span class="hljs-comment">       最后返回树1的结点</span><br><span class="hljs-comment">       将树二加在树一上，对树一进行改造</span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">        */</span><br><br>       <br>       <span class="hljs-keyword">return</span>  combineTree(root1,root2);<br><br>        <br><br><br><br>   &#125;<br><br>   <span class="hljs-keyword">public</span> TreeNode combineTree(TreeNode root1,TreeNode root2)&#123;<br>      <br><br>        <span class="hljs-keyword">if</span>(root1==<span class="hljs-literal">null</span>&amp;&amp;root2==<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">if</span>(root1==<span class="hljs-literal">null</span>&amp;&amp;root2!=<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> root2;<br>       &#125;<br>       <br>       <span class="hljs-keyword">if</span>(root1!=<span class="hljs-literal">null</span>&amp;&amp;root2==<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> root1;<br>       &#125;<br><br>       root1.<span class="hljs-keyword">val</span>=root1.<span class="hljs-keyword">val</span>+root2.<span class="hljs-keyword">val</span>;<br><br>       root1.left=combineTree(root1.left,root2.left);<br>       root1.right=combineTree(root1.right,root2.right);<br><br><br>       <span class="hljs-keyword">return</span> root1;<br>   &#125;<br></code></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/submissions/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> TreeNode searchBST(TreeNode root, int <span class="hljs-keyword">val</span>) &#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        递归：</span><br><span class="hljs-comment">        返回值：TreeNode,传入参数结点和val</span><br><span class="hljs-comment">        终止条件：结点为空或则等于val</span><br><span class="hljs-comment">        单次逻辑：大于val,且右子树不为空就递归右子树</span><br><span class="hljs-comment">                小于val，且左子树不为空就递左子树 </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> search(root,<span class="hljs-keyword">val</span>);<br>      <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode search(TreeNode root, int <span class="hljs-keyword">val</span>)&#123;<br><br>         <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>||root.<span class="hljs-keyword">val</span>==<span class="hljs-keyword">val</span>)&#123;<br><br>             <span class="hljs-keyword">return</span> root;<br><br><br>        &#125;<br>       TreeNode res=<span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">val</span>&lt;root.<span class="hljs-keyword">val</span>&amp;&amp;root.left!=<span class="hljs-literal">null</span>)&#123;<br>             res=search(root.left,<span class="hljs-keyword">val</span>);<br>            <br><br><br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">val</span>&gt;root.<span class="hljs-keyword">val</span>&amp;&amp;root.right!=<span class="hljs-literal">null</span>)&#123;<br>              res=search(root.right,<span class="hljs-keyword">val</span>);<br><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br><br><br>    &#125;<br></code></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/submissions/">98. 验证二叉搜索树 </a></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public boolean is<span class="hljs-constructor">ValidBST(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">    递归：中途遇到不满二叉搜索树的就返回false,如果返回为true,就继续遍历子树结点</span><br><span class="hljs-comment">    注意：并不是简单判断左子结点小于根结点，右子结点大于根节点就能判断它是否是二叉搜索树</span><br><span class="hljs-comment">    而是左子树都小于根节点，右子树都大于根节点</span><br><span class="hljs-comment">    第一种思路：按照中序遍历把所有的结点都放入数组中，然后判断该数组的所有元素是否从小到达排列即可</span><br><span class="hljs-comment">    第二种思路：在中序遍历的递归过程中就进行判断，判断后面的值是否大于前面的最大值，小于就返回false</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    */</span><br>    List&lt;Integer&gt; <span class="hljs-built_in">list</span>=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">in</span><span class="hljs-constructor">Order(<span class="hljs-params">root</span>,<span class="hljs-params">list</span>)</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">list</span>.size<span class="hljs-literal">()</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>.get(i)&lt;=<span class="hljs-built_in">list</span>.get(i-<span class="hljs-number">1</span>))&#123;<br>            return <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    return <span class="hljs-literal">true</span>;<br>&#125;<br><br>public void <span class="hljs-keyword">in</span><span class="hljs-constructor">Order(TreeNode <span class="hljs-params">root</span>,List&lt;Integer&gt; <span class="hljs-params">list</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root==null)&#123;<br>        return;<br>    &#125;<br><br>    <span class="hljs-keyword">in</span><span class="hljs-constructor">Order(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>,<span class="hljs-params">list</span>)</span>;<br>    <span class="hljs-built_in">list</span>.add(root.<span class="hljs-keyword">val</span>);<br>    <span class="hljs-keyword">in</span><span class="hljs-constructor">Order(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>,<span class="hljs-params">list</span>)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/submissions/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-built_in">int</span> get<span class="hljs-constructor">MinimumDifference(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       利用中序遍历的方式将树中的结点都放入到数组中，这时数组中的元素都是</span><br><span class="hljs-comment">       从小到大排序的，那么差值最小的两个结点，肯定是靠在一起的，所以只需要</span><br><span class="hljs-comment">       寻找出数组中前后两个差值最小的即可</span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">        */</span><br><br>        List&lt;Integer&gt; res=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">in</span><span class="hljs-constructor">Order(<span class="hljs-params">root</span>,<span class="hljs-params">res</span>)</span>;<br>        <span class="hljs-built_in">int</span> min=Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;res.size<span class="hljs-literal">()</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(res.get(i)-res.get(i-<span class="hljs-number">1</span>)&lt;min)&#123;<br>                min=res.get(i)-res.get(i-<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        return min;<br><br>   &#125;<br><br>   public void <span class="hljs-keyword">in</span><span class="hljs-constructor">Order(TreeNode <span class="hljs-params">root</span>,List&lt;Integer&gt; <span class="hljs-params">res</span>)</span>&#123;<br><br>       <span class="hljs-keyword">if</span>(root==null)&#123;<br>           return ;<br>       &#125;<br><br>       <span class="hljs-keyword">in</span><span class="hljs-constructor">Order(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>,<span class="hljs-params">res</span>)</span>;<br>       res.add(root.<span class="hljs-keyword">val</span>);<br>       <span class="hljs-keyword">in</span><span class="hljs-constructor">Order(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>,<span class="hljs-params">res</span>)</span>;<br><br>   &#125;<br></code></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/submissions/">501. 二叉搜索树中的众数 - 力扣（LeetCode）</a></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> Solution &#123;<br><br>    List&lt;Integer&gt; res=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> maxcount=<span class="hljs-number">0</span>;<br>    TreeNode pre=<span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] findMode(TreeNode root) &#123;<br><br>        <span class="hljs-comment">/* </span><br><span class="hljs-comment">        先进行左子树遍历</span><br><span class="hljs-comment">        递归二叉树的过程中，进行计数，利用前后指针，不断对比前后指针</span><br><span class="hljs-comment">        只要相等就将计时器加一，反之则将计时器重置为1，然后判断计时器与最大计时器的</span><br><span class="hljs-comment">        大小，相等就重新将该数字放进结果集合，大于就清空结果集合，为了清空之前放进去的哪些</span><br><span class="hljs-comment">        元素，清空之后，在将该数组放进去，然后更新前指针为后指针，然后进行右结点的遍历</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        */</span><br><br>        inOrder(root);<br><br>        <span class="hljs-keyword">int</span>[] ans=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.<span class="hljs-keyword">size</span>()];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;res.<span class="hljs-keyword">size</span>();i++)&#123;<br>            ans[i]=res.get(i);<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> inOrder(TreeNode cur)&#123;<br>        <br><br>        <span class="hljs-keyword">if</span>(cur==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br><br><br>        &#125;<br><br>        inOrder(cur.left);<br>        <br>        <span class="hljs-comment">//计数器</span><br>        <span class="hljs-keyword">if</span>(pre==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">count</span>=<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pre.val==cur.val)&#123;<br>            <span class="hljs-keyword">count</span>++;<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">count</span>=<span class="hljs-number">1</span>;<br><br>        &#125;<br><br>        <span class="hljs-comment">//比较计数次数</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span>==maxcount)&#123;<br>            res.add(cur.val);<br><br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span>&gt;maxcount)&#123;<br>            maxcount=<span class="hljs-keyword">count</span>;<br>            res.clear();<br>            res.add(cur.val);<br>            <span class="hljs-comment">//注意是放入当前节点的值</span><br>           <br>        &#125;<br><br>        <span class="hljs-comment">//更新后指针</span><br><br>        pre=cur;<br><br><br>        inOrder(cur.right);<br><br>        <span class="hljs-keyword">return</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>**<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;<br><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       思路：</span><br><span class="hljs-comment">       使用回溯，即从下往上递归，即后续遍历，当遇到p,q节点就返回，然后处理中间节点</span><br><span class="hljs-comment">       为了将最后的祖先结点返回去，只要左右节点不为空，就返回。</span><br><span class="hljs-comment">       其中一个节点不为空的情况，就返回这个不为空的结点</span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">        */</span><br>       <br><br>       <span class="hljs-keyword">if</span>(root==p||root==q||root==<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> root;<br>       &#125;<br><br>       TreeNode left= lowestCommonAncestor(root.left,p,q);<span class="hljs-comment">//左</span><br>       TreeNode right= lowestCommonAncestor(root.right,p,q);<span class="hljs-comment">//右</span><br><br>       <span class="hljs-keyword">if</span>(left!=<span class="hljs-literal">null</span>&amp;&amp;right!=<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//中</span><br>           <span class="hljs-keyword">return</span> root;<br>       &#125;<br><br>       <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">null</span>&amp;&amp;right!=<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> right;<br><br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left!=<span class="hljs-literal">null</span>&amp;&amp;right==<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> left;<br><br>       &#125;<span class="hljs-keyword">else</span>&#123;<br><br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>       &#125;<br><br>   &#125;<br></code></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/submissions/">235. 二叉搜索树的最近公共祖</a></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;<br><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       利用二叉树的顺序特点，祖先结点一定在[p,q]中，只要递归的过程遇到小于该区间的值，就向右递归</span><br><span class="hljs-comment">       反之，则向左边遍历</span><br><span class="hljs-comment">       终止条件：结点为空</span><br><span class="hljs-comment">       单次逻辑：判断结点值与p,q结点值的大小，大于就递归左子树，小于就递归右子树，在区间中，就返回该节点</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">        */</span><br><br>      <span class="hljs-keyword">return</span>   find(root,p,q);<br>       <br>   &#125;<br><br>   <span class="hljs-keyword">public</span> TreeNode find(TreeNode root, TreeNode p, TreeNode q)&#123;<br><br>       <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>       <span class="hljs-comment">//大于区间</span><br>       <span class="hljs-keyword">if</span>(root.<span class="hljs-keyword">val</span>&gt;p.<span class="hljs-keyword">val</span>&amp;&amp;root.<span class="hljs-keyword">val</span>&gt;q.<span class="hljs-keyword">val</span>)&#123;<br>           TreeNode left=find(root.left,p,q);<br><br>           <span class="hljs-keyword">return</span> left;<br><br>       &#125;<br>       <span class="hljs-comment">//小于区间</span><br>       <span class="hljs-keyword">if</span>(root.<span class="hljs-keyword">val</span>&lt;p.<span class="hljs-keyword">val</span>&amp;&amp;root.<span class="hljs-keyword">val</span>&lt;q.<span class="hljs-keyword">val</span>)&#123;<br>           TreeNode right=find(root.right,p,q);<br><br>           <span class="hljs-keyword">return</span> right;<br><br>       &#125;<br><br>       <span class="hljs-comment">//在区间中</span><br><br>       <span class="hljs-keyword">return</span> root;<br><br>       <br><br>   &#125;<br></code></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/submissions/">701. 二叉搜索树中的插入操作 </a></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public TreeNode insert<span class="hljs-constructor">IntoBST(TreeNode <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        思路:遍历过程中，找到符合条件的空结点，插入即可</span><br><span class="hljs-comment">        递归三要素：</span><br><span class="hljs-comment">        传入参数：根节点和插入值</span><br><span class="hljs-comment">        返回值类型：结点</span><br><span class="hljs-comment">        终止条件：找到为空的结点，将该结点进行插入，然后返回</span><br><span class="hljs-comment">        单次递归逻辑：判断插入节点的值和大小，大于就递归右子树，小于就递归左子树，要改变根节点左右子树的指向</span><br><span class="hljs-comment">        最后返回根节点</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">         */</span><br><br>         <span class="hljs-keyword">if</span>(root==null)<br>         &#123;<br>            TreeNode node=<span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">val</span>)</span>;<br>            return node;<br><br>         &#125;<br><br>         <span class="hljs-keyword">if</span>(root.<span class="hljs-keyword">val</span>&gt;<span class="hljs-keyword">val</span>)&#123;<br>              root.left=insert<span class="hljs-constructor">IntoBST(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>,<span class="hljs-params">val</span>)</span>;<br>         &#125;<br>         <br>        <span class="hljs-keyword">if</span>(root.<span class="hljs-keyword">val</span>&lt;<span class="hljs-keyword">val</span>)&#123;<br>              root.right=insert<span class="hljs-constructor">IntoBST(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>,<span class="hljs-params">val</span>)</span>;<br>         &#125;<br><br>         return root;<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/submissions/">450. 删除二叉搜索树中的节点 - 力扣（LeetCode）</a></p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs xquery">public TreeNode deleteNode(TreeNode<span class="hljs-built_in"> root</span>, int<span class="hljs-built_in"> key</span>) &#123;<br>       /* <br>       注意：这里返回的是可能更新的根节点。<br>       这里更新树结构的方式有五种：<br>       第一种：删除节点的左右子树都为空，直接返回空<br>       第二种：删除节点的左子树为空，右子树不为空，直接让右子树补上，然后返回该柚子结点<br>       第三种：删除节点的左子树不为空，右子树为空，就让左子树补上，然后返回左子结点<br>       第四种：左右子树都不为空，这时候就要将左子树的嫁接到右子树的最下方的左子节点去<br>       第五种：找不到要删除的节点，直接返回跟结点<br><br><br>       这里需要整一颗树，所哟需要递归各自的左右子树，然后返回给上一层，目的是为了更新一整一颗树<br>       小于就递归左子树，大于就递归右子树<br>       <br>       */<br><br>       <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span>==null)&#123;<br>           <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span>.val=<span class="hljs-built_in">=key</span>)&#123;<br><br><br>           <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span>.left==null&amp;<span class="hljs-built_in">&amp;root</span>.right==null)&#123;<br>               <span class="hljs-keyword">return</span> null;<br><br>           &#125;<br>    <br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span>.left!=null&amp;<span class="hljs-built_in">&amp;root</span>.right==null)&#123;<br>               <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>.left;<br><br>           &#125;<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span>.left==null&amp;<span class="hljs-built_in">&amp;root</span>.right!=null)&#123;<br>                <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>.right;<br>               <br>           &#125;<br>          <span class="hljs-keyword">else</span>&#123;<br><br>               TreeNode left<span class="hljs-built_in">=root</span>.right;<br><br>               while(left.left!=null)&#123;<br>                   left=left.left;<br>               &#125;<br><br>               left.left<span class="hljs-built_in">=root</span>.left;<br><br>               <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>.right;<br>               <br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span>.val<span class="hljs-built_in">&gt;key</span>)&#123;<br>          <span class="hljs-built_in"> root</span>.left=deleteNode<span class="hljs-built_in">(root</span>.left<span class="hljs-built_in">,key</span>); <br>       &#125;<br>       <span class="hljs-keyword">if</span><span class="hljs-built_in">(root</span>.val&lt;key)&#123;<br>           <span class="hljs-built_in"> root</span>.right=deleteNode<span class="hljs-built_in">(root</span>.right<span class="hljs-built_in">,key</span>);<br>       &#125;<br><br>       <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br>       <br><br><br><br>   &#125;<br></code></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/submissions/">669. 修剪二叉搜索树 - 力扣（LeetCode）</a></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public TreeNode trim<span class="hljs-constructor">BST(TreeNode <span class="hljs-params">root</span>, <span class="hljs-params">int</span> <span class="hljs-params">low</span>, <span class="hljs-params">int</span> <span class="hljs-params">high</span>)</span> &#123;<br><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       小于最小值的节点保留右子树然后递归，大于最大值的节点保留左子树，然后递归</span><br><span class="hljs-comment">       递归三要素：</span><br><span class="hljs-comment">       终止条件：节点为空</span><br><span class="hljs-comment">       传入值和返回类型：节点名称和最大最小 边界</span><br><span class="hljs-comment">       单次循环逻辑：</span><br><span class="hljs-comment">       节点值小于目标区间，就将去找递归右子树，并且用一个right借助返回值，然后返回</span><br><span class="hljs-comment">        节点值大于目标区间，就将去找递归左子树，并且用一个left借助返回值，然后返回</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        然后就是递归左右子树，更新数的结构</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">        */</span><br>   <span class="hljs-keyword">if</span>(root==null)&#123;<br>       return null;<br>   &#125;<br><br>   <span class="hljs-keyword">if</span>(root.<span class="hljs-keyword">val</span>&lt;low)&#123;<br>       TreeNode right=trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>,<span class="hljs-params">low</span>,<span class="hljs-params">high</span>)</span>;<br>       return right;<br>   &#125;<br>   <span class="hljs-keyword">if</span>(root.<span class="hljs-keyword">val</span>&gt;high)&#123;<br>       TreeNode left=trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>,<span class="hljs-params">low</span>,<span class="hljs-params">high</span>)</span>;<br>       return left;<br>   &#125;<br><br>   root.left=trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>,<span class="hljs-params">low</span>,<span class="hljs-params">high</span>)</span>;<br>   root.right=trim<span class="hljs-constructor">BST(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>,<span class="hljs-params">low</span>,<span class="hljs-params">high</span>)</span>;<br><br><br>   return root;<br><br><br><br>   &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/submissions/">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public TreeNode sorted<span class="hljs-constructor">ArrayToBST(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;<br>           <span class="hljs-comment">/*</span><br><span class="hljs-comment">           因为这是一个有序数组，所有构建二叉树时，就选择中间节点作为划分结点，这样即保证</span><br><span class="hljs-comment">           了有序又保证了是平衡二叉树。</span><br><span class="hljs-comment">           递归三要素：</span><br><span class="hljs-comment">           传入参数：数组，左右边界，返回值类型：结点</span><br><span class="hljs-comment">           终止条件：左边的大于右边的</span><br><span class="hljs-comment">           单词循环逻辑：</span><br><span class="hljs-comment">           每次将中间结点作为根节点，然后使用左子节点存取作半边的结果，是由右子节点存取右半边的部分</span><br><span class="hljs-comment">           最后返回根节点</span><br><span class="hljs-comment">           注释:中间取值的方式不唯一，所以答案不唯一，这里中间取值都是靠左边的</span><br><span class="hljs-comment">            */</span><br><br>            <span class="hljs-built_in">int</span> left=<span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">int</span> right=nums.length-<span class="hljs-number">1</span>;<br>            return build<span class="hljs-constructor">Tree(<span class="hljs-params">nums</span>,<span class="hljs-params">left</span>,<span class="hljs-params">right</span>)</span>;<br><br>   &#125;<br><br>   public TreeNode build<span class="hljs-constructor">Tree(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>,<span class="hljs-params">int</span> <span class="hljs-params">left</span>,<span class="hljs-params">int</span> <span class="hljs-params">right</span>)</span>&#123;<br>       <span class="hljs-keyword">if</span>(left&gt;right)&#123;<br>           return null;<br>       &#125;<br><br>       <span class="hljs-built_in">int</span> mid=left+((right-left)/<span class="hljs-number">2</span>);<br><br>       TreeNode root=<span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">nums</span>[<span class="hljs-params">mid</span>])</span>;<br><br>       root.left=build<span class="hljs-constructor">Tree(<span class="hljs-params">nums</span>,<span class="hljs-params">left</span>,<span class="hljs-params">mid</span>-1)</span>;<br>       root.right=build<span class="hljs-constructor">Tree(<span class="hljs-params">nums</span>,<span class="hljs-params">mid</span>+1,<span class="hljs-params">right</span>)</span>;<br><br>       return root;<br><br><br><br>   &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/submissions/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs typescript">int  pre=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-function"><span class="hljs-title">convertBST</span>(<span class="hljs-params">TreeNode root</span>)</span> &#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        观察可得：每次的加法运算的顺序都是先右中左，</span><br><span class="hljs-comment">       每个根节点的值，就是根节点的值就是右子树的和与节点值得和     </span><br><span class="hljs-comment">       这里要使用 前后指针，方便 进行运算，因为当前节点得值就是前一个</span><br><span class="hljs-comment">       结点得值和当前接结点值的和</span><br><span class="hljs-comment">       递归：</span><br><span class="hljs-comment">       传入参数：当前结点，无参返回</span><br><span class="hljs-comment">       终止条件：遇到为空</span><br><span class="hljs-comment">       单次循环逻辑：按照右中左的顺序进行遍历，</span><br><span class="hljs-comment">       中间结点需要处理，即求和</span><br><span class="hljs-comment">       然后把前一个结点的值更新为当前结点的值</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">         */</span><br><br>        <br>         getSum(root);<br><br>         <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">getSum</span>(<span class="hljs-params">TreeNode node</span>)</span>&#123;<br><br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//右</span><br>        getSum(node.right);<br>        <span class="hljs-comment">//中</span><br>        node.val+=pre;<br>        pre=node.val;<br>        <span class="hljs-comment">//左</span><br>        getSum(node.left);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>回溯的本质就是穷举，也是递归</p>
<p>回溯法常用于解决集合中查找子集，排序方式，解数独</p>
<p>回溯的三要素：</p>
<p>终止条件：满足什么条件就返回</p>
<p>返回值和传入参数类型：没有返回值，参数类型依据单次 循环逻辑而定</p>
<p>但次循环逻辑：一个foe循环，表示遍历的宽度，对应数的宽度，然后就是递归，对应的就是数的深度</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">77. 组合 - 力扣（LeetCode）</a></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">LinkedList&lt;<span class="hljs-type">Integer</span>&gt; nums=<span class="hljs-built_in">new</span> LinkedList&lt;&gt;();<br>   List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; res=<span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br><br>   <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; combine(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       for循环用于控制递归的宽度n，递归用于递归的深度，也就是k</span><br><span class="hljs-comment">       回溯三要素：</span><br><span class="hljs-comment">       终止条件：子集的长度等于k,就将子集添加进最终得结果集合</span><br><span class="hljs-comment">       传入参数：遍历的宽度n,递归的深度，还有下一次的起始递归位置</span><br><span class="hljs-comment">       单次逻辑：先判断子集的长度是否满足条件，不满足就进行for循环，开始的位置就是传入的递归位置，</span><br><span class="hljs-comment">       然后将该结点添加进结果集合终，然后递归，起始的位置加一，然后再将添加 的元素移除结果集合</span><br><span class="hljs-comment">       注意：这里的范围时[1,n];</span><br><span class="hljs-comment">       减值优化：当进行递归的时候，发现后面元素的个数已经不能满足需要的元素个数，就不需要进行递归了。</span><br><span class="hljs-comment">       所有范围可以优化至[startindex,n-(k-nums.size)+1]</span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">        */</span><br><br><br>        backtracking(n,k,<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> res;<br><br><br><br>   &#125;<br><br>   <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> backtracking(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> startindex)&#123;<br>       <span class="hljs-keyword">if</span>(nums.size()==k)&#123;<br>           res.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList(nums));<br>           <span class="hljs-keyword">return</span> ;<br>       &#125;<br><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=startindex;i&lt;=n-(k-nums.size())+<span class="hljs-number">1</span>;i++)&#123;<br>           nums.<span class="hljs-keyword">add</span>(i);<br>           backtracking(n,k,i+<span class="hljs-number">1</span>);<br>           nums.removeLast();<br><br>       &#125;<br><br><br>   &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/submissions/">216. 组合总和 III - 力扣（LeetCode）</a></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">思路：<br>回溯三要素：<br>传入的参数：<span class="hljs-built_in">n</span>,k,<span class="hljs-built_in">sum</span>,startindex<br>终止条件：和<span class="hljs-built_in">sum</span>大于<span class="hljs-built_in">n</span>就直接跳出,当path的长度等于k,且和定于<span class="hljs-built_in">n</span>,就将Path加入到结果集合中<br>单次逻辑：循环遍历，然后进行递归回溯，将遍历到的结点先加入path,然后求和，再递归<br>起始步子从下一个开始，然后从path中取出结点值，然后减去节点值<br></code></pre></td></tr></table></figure>



<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; res=<span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>   LinkedList&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>=<span class="hljs-built_in">new</span> LinkedList&lt;&gt;();<br><br>   <br>   <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; combinationSum3(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br><br>       backTraking(n,k,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br>   <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> backTraking(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k ,<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> startIndex)&#123;<br><br>       <span class="hljs-keyword">if</span>(sum&gt;n)&#123;<br><br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">if</span>(<span class="hljs-type">path</span>.size()==k)&#123;<br>       <br>           <span class="hljs-keyword">if</span>(sum==n)&#123;<br>               res.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList(<span class="hljs-type">path</span>));<br>           &#125;<br><br>           <span class="hljs-keyword">return</span> ;<br>       &#125;<br><br><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=startIndex;i&lt;=<span class="hljs-number">9</span>-(k-<span class="hljs-type">path</span>.size())+<span class="hljs-number">1</span>;i++)&#123;<br>           <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(i);<br>           sum+=i;<br>           backTraking(n,k,sum,i+<span class="hljs-number">1</span>);<br>           sum-=i;<br>           <span class="hljs-type">path</span>.removeLast();<br>       &#125;<br><br>   &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/submissions/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String<span class="hljs-literal">[]</span> s=&#123;<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>,<span class="hljs-string">&quot;ghi&quot;</span>,<span class="hljs-string">&quot;jkl&quot;</span>,<span class="hljs-string">&quot;mno&quot;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>,<span class="hljs-string">&quot;tuv&quot;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>   StringBuilder path=<span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;<br>   List&lt;String&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-constructor">ArrayList()</span>;<br>   public List&lt;String&gt; letter<span class="hljs-constructor">Combinations(String <span class="hljs-params">digits</span>)</span> &#123;<br><br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       思路：</span><br><span class="hljs-comment">       这里要 解决的问题，数字与字符串之间的映射：使用一个字符数组，将这个字符串存在对应的位置，使用</span><br><span class="hljs-comment">       下标代表数字</span><br><span class="hljs-comment">       回溯三要素：</span><br><span class="hljs-comment">       终止条件：递归的深度达到了输入数字字符串的长度 </span><br><span class="hljs-comment">       单次循环逻辑：先取出数字中的单个字符，然后用单个数字，取出代表的字符串</span><br><span class="hljs-comment">       然后进行循环，每次都是从0，开始循环的宽度是字符串的长度，每次都将字符串中的一个字符放入到</span><br><span class="hljs-comment">       path中，然后递归，每次递归的深度加一，最后回溯</span><br><span class="hljs-comment">       传入的参数，这里需要一个原先的数字字符串，还有就是递归的深度</span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">       </span><br><span class="hljs-comment">        */</span><br><br>        <span class="hljs-keyword">if</span>(digits.length<span class="hljs-literal">()</span>==<span class="hljs-number">0</span>)&#123;<br>            return res;<br><br>        &#125;<br><br>        back<span class="hljs-constructor">Traking(<span class="hljs-params">digits</span>,0)</span>;<br><br>        return res;<br><br>   &#125;<br>   <br>   public void back<span class="hljs-constructor">Traking(String <span class="hljs-params">digits</span>,<span class="hljs-params">int</span> <span class="hljs-params">index</span>)</span>&#123;<br>       <span class="hljs-keyword">if</span>(index==digits.length<span class="hljs-literal">()</span>)&#123;<br>           res.add(<span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">path</span>)</span>);<br>           return;<br><br>       &#125;<br>       <span class="hljs-comment">//取数字字符</span><br>       <span class="hljs-built_in">int</span> num=digits.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">index</span>)</span>-<span class="hljs-character">&#x27;0&#x27;</span>;<br>       String s1=s<span class="hljs-literal">[<span class="hljs-identifier">num</span>]</span>;<br><br>       <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;s1.length<span class="hljs-literal">()</span>;i++)&#123;<br>           <br>           path.append(s1.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>);<br>           back<span class="hljs-constructor">Traking(<span class="hljs-params">digits</span>,<span class="hljs-params">index</span>+1)</span>;<br>           path.delete<span class="hljs-constructor">CharAt(<span class="hljs-params">path</span>.<span class="hljs-params">length</span>()</span>-<span class="hljs-number">1</span>);<br><br>       &#125;<br><br><br><br>   &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/submissions/">39. 组合总和 - 力扣（LeetCode）</a></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">LinkedList&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>=<span class="hljs-built_in">new</span> LinkedList&lt;&gt;();<br>   List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; res=<span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; combinationSum(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target) &#123;<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">      本问题可以再组合问题三上改进得到，因为这里可以取重复元素，就代表着起始位置就不用加一了。</span><br><span class="hljs-comment">      回溯三要素：</span><br><span class="hljs-comment">      终止条件：元素的和大于目标求和</span><br><span class="hljs-comment">      单次逻辑：只要元素和大于目标和就直接返回，反之如果等于就将集合添加进结果集合中，</span><br><span class="hljs-comment">      然后就是循环回溯，起始位置为上一次的起始位置，递归前先加上这个元素的值，然后添加进结果集中，</span><br><span class="hljs-comment">      递归后再减去这个元素的值，并将其移出集合</span><br><span class="hljs-comment">      传入参数：数组，目标值，和，起始坐标</span><br><span class="hljs-comment">      </span><br><span class="hljs-comment">       */</span><br>       backTracking(candidates,target,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><br>       <span class="hljs-keyword">return</span> res;<br><br>  &#125;<br><br>  <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> backTracking(<span class="hljs-type">int</span>[] candidates,<span class="hljs-type">int</span> target,<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>)&#123;<br>      <span class="hljs-keyword">if</span>(sum&gt;target)&#123;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span>(sum==target)&#123;<br>          res.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList(<span class="hljs-type">path</span>));<br><br>          <span class="hljs-keyword">return</span>;<br><br>      &#125;<br><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-keyword">index</span>;i&lt;candidates.length;i++)&#123;<br><br>          <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(candidates[i]);<br>          sum+=candidates[i];<br>          backTracking(candidates,target,sum,i);<br>          <span class="hljs-type">path</span>.removeLast();<br>          sum-=candidates[i];<br><br>      &#125;<br><br><br><br>  &#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/submissions/">78. 子集 - 力扣（LeetCode）</a></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">LinkedList&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>=<span class="hljs-built_in">new</span> LinkedList&lt;&gt;();<br>  List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; res=<span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>  <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; subsets(<span class="hljs-type">int</span>[] nums) &#123;<br><br>  <br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">      思路：</span><br><span class="hljs-comment">      回溯三要素：</span><br><span class="hljs-comment">      终止条件：起始坐标大于等于数组长度</span><br><span class="hljs-comment">      单次循环逻辑：将递归过程中的结点都加入到结果集中，递归每一次的开始，就是上一次递归的下一个</span><br><span class="hljs-comment">      传入的参数：nums，起始坐标        </span><br><span class="hljs-comment">       */</span><br><br>      backTracking(nums,<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">return</span> res;<br><br>  &#125;<br>  <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> backTracking(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>)&#123;<br><br>      res.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList(<span class="hljs-type">path</span>));<br><br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">index</span>&gt;=nums.length)&#123;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-keyword">index</span>;i&lt;nums.length;i++)&#123;<br>          <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(nums[i]);<br>          backTracking(nums,i+<span class="hljs-number">1</span>);<br>          <span class="hljs-type">path</span>.removeLast();<br>      &#125;<br><br>  &#125;<br></code></pre></td></tr></table></figure>



<h2 id="青训笔试"><a href="#青训笔试" class="headerlink" title="青训笔试"></a>青训笔试</h2><p>【编程题】幼儿园有 N 个孩子玩游戏，随机围成了一个圈，老师最终想让所有男生排列到一起，所有女生排列到一起。每次老师可以命令两个孩子交换位置，求最小的命令次数：</p>
<p>N&lt;=100</p>
<p>语言限定：C++、Java、Golang</p>
<p>输入3 FMF</p>
<p>输出 0</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>

<p>【编程题】n 个人一起玩狼人杀，按从 1 到 n 的顺序编号，据说，这群人当中有一个预言家。如果预言家真的存在，那么： 1）预言家不会信任任何人。 2）每个人（除了预言家）都信任预言家。 最多只有一个人同时满足 1 和 2 。 给定一个数组 trust ，其中 trust[i] = [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。如果预言家存在并且可以确定他的身份，请返回预言家的编号；否则，返回 -1 。 提示： 1 &lt;= n &lt;= 1000；0 &lt;= trust.length &lt;= 100；trust[i].length == 2；trust 中的所有trust[i] = [ai, bi] 互不相同；ai != bi；1 &lt;= ai；bi &lt;= n</p>
<p>描述</p>
<p>n 个人一起玩狼人杀，按从 1 到 n 的顺序编号，据说，这群人当中有一个预言家。如果预言家真的存在，那么：</p>
<p>1）预言家不会信任任何人。</p>
<p>2）每个人（除了预言家）都信任预言家。</p>
<p>最多只有一个人同时满足 1 和 2 。</p>
<p>给定一个数组 trust ，其中 trust[i] = [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。如果预言家存在并且可以确定他的身份，请返回预言家的编号；否则，返回 -1 。</p>
<p>提示：</p>
<p>1 &lt;= n &lt;= 1000；0 &lt;= trust.length &lt;= 100；trust[i].length == 2；trust 中的所有trust[i] = [ai, bi] 互不相同；ai != bi；1 &lt;= ai；bi &lt;= n</p>
<p>语言限定：C++、Java、Golang</p>
<p>输入</p>
<p>n为人数；</p>
<p>trust数组如题干所述；</p>
<p>输出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>



<h2 id="热身赛"><a href="#热身赛" class="headerlink" title="热身赛"></a>热身赛</h2><p>牛牛得到了一个字符串（可能含有空格），他希望在这些字符串中提取出数字。 </p>
<p>  例如：a1b23c456d007890中可以提取出1, 23, 456, 7890共4个数字。 </p>
<p>  现在，他得到了一个长度高达1000的字符串，请你帮他提取出所有的数字。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>

<p>Alice 和 Bob在玩游戏。一共玩了 nnn局。二者的胜利的概率都是 12\frac{1}{2}21。求 Alice 赢几次的可能性最大。输出最有可能赢几次，如果有多个结果，从小到大输出。</p>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/51537/A">A-赢的次数_2023成都大学contest 1 (nowcoder.com)</a></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Main&#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args)&#123;<br>        Scanner sc=<span class="hljs-built_in">new</span> Scanner(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">in</span>);<br>        <br>        <span class="hljs-type">int</span> n=sc.nextInt();<br>        <br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(n/<span class="hljs-number">2</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(n/<span class="hljs-number">2</span>+&quot; &quot;);<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <br>        <br>    &#125;<br>      <br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure>



<p>链接：<a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/51537/C">https://ac.nowcoder.com/acm/contest/51537/C</a><br>来源：牛客网</p>
<p>法协会有三个主要部门，算法组、项目组和事务组。现在指导老师CD想为大家发福利，给每个组发若干瓶肥宅快乐水，要求各组得到的肥宅快乐水数量相同，并且各组内能够按人数平分(每人至少分一瓶)。现在Reverie统计了三个组的人数，你能帮CD老师算一下至少要准备多少瓶肥宅快乐水吗？</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span></span>&#123;<br>        Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Scanner</span>(System.in);<br>        <br>        <br>        List&lt;Integer&gt; res=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>            <span class="hljs-keyword">int</span> n=sc.<span class="hljs-built_in">nextInt</span>();<br>            res.<span class="hljs-built_in">add</span>(n);<br>            <br>        &#125;<br>        <span class="hljs-keyword">int</span> a=res.<span class="hljs-built_in">get</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">int</span> b=res.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> c=res.<span class="hljs-built_in">get</span>(<span class="hljs-number">2</span>);<br>        <br>        <br>        <span class="hljs-keyword">int</span> max=Collections.<span class="hljs-built_in">max</span>(res);<br>        <span class="hljs-comment">//取最小公倍数</span><br>        <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span>)&#123;<br>             k=max*j;<br>            <span class="hljs-keyword">if</span>(k%a==<span class="hljs-number">0</span>&amp;&amp;k%b==<span class="hljs-number">0</span>&amp;&amp;k%c==<span class="hljs-number">0</span>)&#123;<br>                <br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            j++;<br>        &#125;<br>        <br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-number">3</span>*k);<br>       <br>        <br>        <br>        <br>    &#125;<br>      <br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://plboss-imges.oss-cn-chengdu.aliyuncs.com/master/image-20230222225838810.png" srcset="/img/loading.gif" lazyload alt="image-20230222225838810"></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>源码心经</div>
      <div>http://example.com/2023/02/28/源码心经/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>February 28, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/02/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93/" title="学习之道">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">学习之道</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/02/22/%E4%B8%94%E5%90%AC%E9%A3%8E%E5%90%9F/" title="且听风吟">
                        <span class="hidden-mobile">且听风吟</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
